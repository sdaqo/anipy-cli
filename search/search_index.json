{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the anipy-cli documentation!","text":""},{"location":"#what-even-is-this","title":"What even is this?","text":"<p>A Little tool written in python to watch and download anime from the terminal (the better way to watch anime). This project's main aim is to create a enjoyable anime watching and downloading experience, directly in the terminal - your favorite place.</p> <p>Features include: Seaonals mode, AniList and MyAnimeList integration, custom post-download scripts, automatic remuxing, discord presence and many more! You can even use your own files instead of online anime sites!</p> <p>Since the version 3 rewrite this project is split into api and frontend, this makes it easy to integrate this into your project!</p>"},{"location":"#you-are-just-here-for-the-client","title":"You are just here for the client?","text":"<p>As one wise man once said:</p> <p>I DONT GIVE A FUCK ABOUT THE FUCKING CODE! i just want to download this stupid fucking application and use it.</p> <p>WHY IS THERE CODE??? MAKE A FUCKING .EXE FILE AND GIVE IT TO ME. these dumbfucks think that everyone is a developer and understands code. well i am not and i don't understand it. I only know to download and install applications. SO WHY THE FUCK IS THERE CODE? make an EXE file and give it to me. STUPID FUCKING SMELLY NERDS</p> <p><sub>Please do not take this seriously this is some stupid copypasta</sub></p> <p>We do not have a .exe but we have pipx: <code>pipx install anipy-cli</code></p> <p>Check out Getting Started - CLI for better instructions and advice!</p>"},{"location":"#you-want-to-use-the-api-for-your-project","title":"You want to use the api for your project?","text":"<p>Feel free to - please check out Getting Started - API for instructions</p>"},{"location":"#credits","title":"Credits!","text":""},{"location":"#heavily-inspired-by-httpsgithubcompystardustani-cli","title":"Heavily inspired by https://github.com/pystardust/ani-cli/","text":""},{"location":"#all-contributors-for-contributing","title":"All contributors for contributing","text":"<p>If you want to contribute as well check out Contributing</p> <p>Legal Disclaimer</p>"},{"location":"availabilty/","title":"Player/Provider Availabiltiy","text":"<p>This is page lists available/supported providers/players and their capabilities.</p>"},{"location":"availabilty/#current-version","title":"Current Version","text":"<p>Version: 3.5.0</p>"},{"location":"availabilty/#providers","title":"Providers","text":"Identifier URL Filter capabilties <sup>1</sup> Season Search <sup>2</sup> Notes Reference allanime https://allmanga.to/ YEAR, SEASON, MEDIA_TYPE, NO_QUERY Yes Hover Me Recommended AllAnimeProvider animekai https://animekai.to/ YEAR, SEASON, STATUS, MEDIA_TYPE, NO_QUERY Yes Hover Me AnimekaiProvider"},{"location":"availabilty/#players","title":"Players","text":"Name Recognised Stem(s) <sup>3</sup> Project URL(s) Sub-process Code Reference mpv mpv, mpvnet https://mpv.io/, https://github.com/mpvnet-player/mpv.net Yes Mpv Syncplay syncplay https://syncplay.pl/ Yes Syncplay VLC Media Player vlc https://www.videolan.org/vlc/ Yes Vlc Mpv Controlled mpv-controlled https://github.com/jaseg/python-mpv No MpvControllable IINA iina https://iina.io/ Yes Iina"},{"location":"availabilty/#version-340","title":"Version 3.4.0","text":"<p>Version: 3.4.0</p>"},{"location":"availabilty/#providers_1","title":"Providers","text":"Identifier URL Filter capabilties <sup>1</sup> Season Search <sup>2</sup> Notes Reference animekai https://animekai.to/ YEAR, SEASON, STATUS, MEDIA_TYPE, NO_QUERY Yes Hover Me Recommended AnimekaiProvider"},{"location":"availabilty/#players_1","title":"Players","text":"Name Recognised Stem(s) <sup>3</sup> Project URL(s) Sub-process Code Reference mpv mpv, mpvnet https://mpv.io/, https://github.com/mpvnet-player/mpv.net Yes Mpv Syncplay syncplay https://syncplay.pl/ Yes Syncplay VLC Media Player vlc https://www.videolan.org/vlc/ Yes Vlc Mpv Controlled mpv-controlled https://github.com/jaseg/python-mpv No MpvControllable IINA iina https://iina.io/ Yes Iina"},{"location":"availabilty/#version-330","title":"Version 3.3.0","text":"<p>Version: 3.3.0</p>"},{"location":"availabilty/#providers_2","title":"Providers","text":"Identifier URL Filter capabilties <sup>1</sup> Season Search <sup>2</sup> Notes Reference gogoanime https://gogoanime3.co YEAR, SEASON, STATUS, NO_QUERY Yes Hover Me GoGoProvider anivibe https://anivibe.net/ YEAR, SEASON, STATUS, MEDIA_TYPE, NO_QUERY Yes Hover Me AnivibeProvider"},{"location":"availabilty/#players_2","title":"Players","text":"Name Recognised Stem(s) <sup>3</sup> Project URL(s) Sub-process Code Reference mpv mpv, mpvnet https://mpv.io/, https://github.com/mpvnet-player/mpv.net Yes Mpv Syncplay syncplay https://syncplay.pl/ Yes Syncplay VLC Media Player vlc https://www.videolan.org/vlc/ Yes Vlc Mpv Controlled mpv-controlled https://github.com/jaseg/python-mpv No MpvControllable IINA iina https://iina.io/ Yes Iina"},{"location":"availabilty/#version-320","title":"Version 3.2.0","text":"<p>Version: 3.2.0</p>"},{"location":"availabilty/#providers_3","title":"Providers","text":"Identifier URL Filter capabilties <sup>1</sup> Season Search <sup>2</sup> Notes Reference gogoanime https://gogoanime3.co YEAR, SEASON, STATUS, NO_QUERY Yes Hover Me GoGoProvider yugenanime https://yugenanime.tv YEAR, SEASON, STATUS, MEDIA_TYPE, NO_QUERY Yes Hover Me Recommended YugenProvider"},{"location":"availabilty/#players_3","title":"Players","text":"Name Recognised Stem(s) <sup>3</sup> Project URL(s) Sub-process Code Reference mpv mpv, mpvnet https://mpv.io/, https://github.com/mpvnet-player/mpv.net Yes Mpv Syncplay syncplay https://syncplay.pl/ Yes Syncplay VLC Media Player vlc https://www.videolan.org/vlc/ Yes Vlc Mpv Controlled mpv-controlled https://github.com/jaseg/python-mpv No MpvControllable IINA iina https://iina.io/ Yes Iina"},{"location":"availabilty/#version-300","title":"Version 3.0.0","text":"<p>Version: 3.0.0</p>"},{"location":"availabilty/#providers_4","title":"Providers","text":"Identifier URL Filter capabilties <sup>1</sup> Season Search <sup>2</sup> Notes Reference gogoanime https://gogoanime3.co YEAR, SEASON, STATUS, NO_QUERY Yes Hover Me Recommended GoGoProvider"},{"location":"availabilty/#players_4","title":"Players","text":"Name Recognised Stem(s) <sup>3</sup> Project URL(s) Sub-process Code Reference mpv mpv, mpvnet https://mpv.io/, https://github.com/mpvnet-player/mpv.net Yes Mpv Syncplay syncplay https://syncplay.pl/ Yes Syncplay VLC Media Player vlc https://www.videolan.org/vlc/ Yes Vlc Mpv Controlled mpv-controlled https://github.com/jaseg/python-mpv No MpvControllable <ol> <li> <p>Look here for infos about this here, this is only important for API usage.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>This is a cli-specific capability, if a provider has the filter capabilities YEAR, SEASON and NO_QUERY it is eligible for this.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>The Stem is the end part of a path without it's suffix e.g. the stem of <code>mpv.exe</code> is <code>mpv</code>.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"contributing/","title":"Contributing","text":"<p>Hey, thanks for considering to contribute!</p> <p>If you did this before you probably know the gist, but check out this little guide to get everything set-up!</p>"},{"location":"contributing/#setup-environment-for-codedocs-changes","title":"Setup environment for code/docs changes","text":"<ol> <li>Install Poetry for project managment, it is like pip but better and feature-richer. You can work on this project without it, but I highly recommend not to do this.</li> <li>Clone: <code>git clone https://github.com/sdaqo/anipy-cli &amp;&amp; cd anipy-cli</code></li> <li>Initiate your environment: <code>poetry install --with dev,docs</code>, this installs all the dependencies and some development tools.</li> <li>(Optional) If you are working on the API and you want to be able to test your changes in the cli, you can run <code>poetry run poe enter-dev</code>. (this changes the api dependency to the local <code>../api</code>)</li> <li>Open your edior, you can either run <code>poetry run &lt;your-editor&gt;</code> or <code>poetry shell</code> to get a shell in the virtual environment and run your editor from there, some editors like vscode automatically enter the venv as far as I know.</li> <li>Make your changes :)</li> <li>Check your changes<ul> <li>Run <code>poetry run anipy-cli</code> to run the cli.</li> <li>Run <code>poetry run python</code> to run python from the virtual environment.</li> <li>Run <code>poetry run poe docs-serve</code> to open host the docs locally, this is helpful if you are making changes to the docs.</li> </ul> </li> <li>Run <code>poetry run poe polish</code> before commiting to format and lint your code. The linter will tell you what you did wrong, fix that if you think the suggestion from the linter is reasonable, if not don't bother. Also, please do not concern yourself with linter errors that you did not introduce!</li> <li>Run <code>poetry run poe exit-dev</code> if you ran the command in step 4.</li> <li>Push &amp; Pull Request!</li> </ol>"},{"location":"contributing/#project-structure","title":"Project structure","text":"<pre><code>.\n\u251c\u2500\u2500 api\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pyproject.toml # spec file for api\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src \n\u2502\u00a0\u00a0     \u2514\u2500\u2500 anipy_api # api source\n\u251c\u2500\u2500 cli\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pyproject.toml # spec file for cli\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src \n\u2502\u00a0\u00a0     \u2514\u2500\u2500 anipy_cli # cli source\n\u251c\u2500\u2500 docs # documentation\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 mkdocs.yml # documentation config\n\u251c\u2500\u2500 pyproject.toml # (spec) file for whole project\n\u2514\u2500\u2500 scripts # utility scripts\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"contributing/#tests","title":"Tests","text":"<p>No. Frankly, I am to lazy to write tests, but I do have it on my to-do, expect nothing though!</p>"},{"location":"getting-started-api/","title":"Getting started with the API","text":""},{"location":"getting-started-api/#installation","title":"Installation","text":"<ul> <li>Via poetry: <pre><code>poetry add anipy-api\n</code></pre></li> <li>Via poetry (from source): <pre><code>poetry add \"git+https://github.com/sdaqo/anipy-cli.git#subdirectory=api\"\n</code></pre></li> <li>Via pip:  <pre><code>pip install anipy-api\n</code></pre></li> <li>Via pip (from source):  <pre><code>pip install \"git+https://github.com/sdaqo/anipy-cli.git#subdirectory=api\"\n</code></pre></li> </ul>"},{"location":"getting-started-api/#introduction","title":"Introduction","text":"<p>If you do not want to see examples and dive directly into the api, please go to the Code Reference you will find everything you need there, even stuff not covered in the examples! </p> <p>You can also check out the code of the cli if you want!</p>"},{"location":"getting-started-api/#how-to-read-this","title":"How to read this?","text":"<p>All the important things are covered in the examples, just click through them. I recommend to read the provider section first!</p>"},{"location":"getting-started-api/examples/anime/","title":"2. Anime","text":""},{"location":"getting-started-api/examples/anime/#representing-an-anime","title":"Representing an anime","text":"<p>On the last page we learned how to use the provider to search for anime. This page covers the Anime class, it always represents a single anime.</p>"},{"location":"getting-started-api/examples/anime/#how-to-get-an-anime-object","title":"How to get an Anime object","text":"<pre><code>from anipy_api.anime import Anime\n\nprovider = ... # (1)\nresults = provider.get_search(\"frieren\")\n\nanime = []\n\nfor r in results:\n    anime.append(Anime.from_search_result(provider, r))\n    # or if you really want:\n    anime.append(Anime(provider, r.name, r.identifier, r.languages))\n</code></pre> <ol> <li>The provider, check the provider page.</li> </ol>"},{"location":"getting-started-api/examples/anime/#get-episodes","title":"Get episodes","text":"<p>A Episode is either an integer or a float (for .5 episodes).</p> <pre><code>from anipy_api.provider import LanguageTypeEnum\n\nanime = ...\n# List of Episode-type numbers\nepisodes = anime.get_episodes(lang=LanguageTypeEnum.SUB) # (1)\n</code></pre> <ol> <li>For episodes and videos you have to always specify the language type you want    to get the episodes/videos in. To check which languages the anime supports,    check the <code>languages</code> attribute of the anime.     If the language type you provide is not supported by the anime both the methods for getting episodes and video streams    will throw a LangTypeNotAvailableError error.</li> </ol>"},{"location":"getting-started-api/examples/anime/#get-video-streams","title":"Get video streams","text":"<p>Either use get_video or get_videos, the difference is that one filters out 1 stream based on quality. Both return ProviderStream objects.</p> <pre><code>from anipy_api.provider import LanguageTypeEnum\n\nanime = ...\n\nepisode_1_stream = anime.get_video(\n    episode=1, \n    lang=LanguageTypeEnum.SUB,\n    preferred_quality=720 # (1)\n)\n# or get a list of streams that you can filter yourself\nepisode_1_streams = anime.get_videos(1, LanguageTypeEnum.SUB)\n</code></pre> <ol> <li>Check the reference for information about    the <code>preferred_quality</code> argument.</li> </ol>"},{"location":"getting-started-api/examples/anime/#get-anime-info","title":"Get anime info","text":"<p>The <code>get_info</code> method returns a PoviderInfoResult object. <pre><code>anime = ...\ninfo = anime.get_info() # (1)\n\nprint(f\"The anime's name is {info.name} and it has these genres: {info.genres}!\")\n</code></pre></p> <ol> <li>You do not need to specify the language for the info, because it is expected to be the same for both sub and dub.</li> </ol>"},{"location":"getting-started-api/examples/anime/#what-now","title":"What now?","text":"<p>Keep your ProviderStream objects and move on to 3. Downloader or 4. Player!</p>"},{"location":"getting-started-api/examples/downloader/","title":"3. Downloader","text":""},{"location":"getting-started-api/examples/downloader/#downloading","title":"Downloading","text":"<p>When downloading, you use the Downloader class, it can handle various stream formats. When downloading you can choose between several download methods:</p> <ul> <li>download: This method is just a generic method that supports m3u8, mp4 and many more stream formats. It assumes ffmpeg is installed on the machine please look at the reference for more info.</li> <li>m3u8_download: Download a m3u8 playlist.</li> <li>mp4_download: Download a mp4 stream.</li> <li>ffmpeg_download: Download any stream supported by ffmpeg. This requires ffmpeg to be installed on the system!</li> </ul> <pre><code>from pathlib import Path\n\nfrom anipy_api.download import Downloader\nfrom anipy_api.provider import LanguageTypeEnum\n\nanime = ...\nstream = anime.get_video(1, LanguageTypeEnum.SUB, preferred_quality=1080)\n\ndef progress_callback(percentage: float): # (1)\n    print(f\"Progress: {percentage:.1f}%\", end=\"\\r\")\n\ndef info_callback(message: str): # (2)\n    print(f\"Message from the downloader: {message}\")\n\ndef error_callback(message: str): # (3)\n    s.write(f\"Soft error from the downloader: {message}\")\n\n\ndownloader = Downloader(progress_callback, info_callback, error_callback)\ndownload_path = downloader.download( # (4)\n    stream=stream,\n    download_path=Path(\"~/Downloads\"),\n    container=\".mkv\", # (5)\n    maxRetry=3 # (6)\n    ffmpeg=False # (7)\n)\n</code></pre> <ol> <li>The progress callback gets called on progress-related tasks like downloading or remuxing in the Downloader.</li> <li>The info callback gets called on information coming from the downloader.</li> <li>The error callback gets called on non-fatal errors coming from the downloader.</li> <li>Always make sure to use the resulting path of the methods, because they may alter the path passed to them! This also applies to the other download methods!</li> <li>With optional container argument the downloader will use ffmpeg to remux the video if the container is not the same as specified, note that this will trigger the <code>progress_callback</code> for remuxing!</li> <li>The downloader will always try the download three times. The retry count can be adjusted here; any errors encountered use the <code>error_callback</code>.</li> <li>For the other arguments check the reference!</li> </ol>"},{"location":"getting-started-api/examples/locallist/","title":"6. Local List","text":""},{"location":"getting-started-api/examples/locallist/#serializing-and-de-serializing-anime","title":"Serializing and de-serializing anime","text":"<p>The local lists feature is more a feature meant for the cli, but you may use it for easy (de-) serialization of Anime objects including some extra state data for tracking progress.</p>"},{"location":"getting-started-api/examples/locallist/#usage","title":"Usage","text":"<p>All the data is stored in json format.</p> <pre><code>from anipy_api.locallist import LocalList\nfrom anipy_api.provider import LanguageTypeEnum\nfrom anipy_api.anime import Anime\n\nlocal_list = LocalList(\n    \"/path/to/list.json\",\n    migrate_cb=None # (1)\n)\n\nanime = ...\n\n# Adding an anime\nentry = local_list.update(anime, episode=1, language=LanguageTypeEnum.SUB) # (2)\n\n# Updating it\nupdated_entry = local_list.update(anime, episode=2) # (3)\n\n# Get entry for anime\nentry = local_list.get(anime)\n\n# Get all entries in file\nentries = [\n    Anime.from_local_list_entry(entry)\n    for entry in local_list.get_all() # (4)\n]\n\n# Delete entry\ndelted_entry = local_list.delete(anime) # (5)\n</code></pre> <ol> <li>Optionally, you may pass a migration callback. This gets called if parsing    the data of the json file into the data format fails. Check out    MigrateCallback.</li> <li>The fields you can pass (after the anime argument) correspond to the fields    in LocalListEntry. When adding an anime    make sure you are always passing at least the episode and language fields.</li> <li>The anime argument can be a Anime or a    LocalListEntry object, meaning we could    also pass <code>entry</code> here instead of <code>anime</code>.</li> <li>You can use    Anime.from_local_list_entry to    convert a local list entry into an Anime object</li> <li>Again here you can pass both Anime and    LocalListEntry.</li> </ol>"},{"location":"getting-started-api/examples/myanimelist/","title":"5. MyAnimeList","text":""},{"location":"getting-started-api/examples/myanimelist/#why","title":"Why?","text":"<p>Uhm, I did not find a proper implementation of the MyAnimeList v2 api for python... so yeah.</p>"},{"location":"getting-started-api/examples/myanimelist/#authentication","title":"Authentication","text":"<p>The MyAnimeList class implement basic authentication via a username/password combo or via a refresh token.</p> <pre><code>from anipy_api.mal import MyAnimeList\n\n# password\nmal = MyAnimeList.from_password_grant( # (1)\n    user=\"test\",\n    password=\"test\",\n    client_id=None # (2)\n)\n# or refresh token\nmal = MyAnimeList.from_rt_grant(\n    refresh_token=\"random-gibberish112mnsd8123109\",\n    client_id=\"more-random-suff1231283123102938\" # (3)\n)\n</code></pre> <ol> <li>Those functions may throw a    MyAnimeListError when auth fails, wrap    them in a try/except.</li> <li>Please note that that currently no complex oauth autentication scheme is    implemented, this client uses the client id of the official MyAnimeList    android app, this gives us the ability to login via a username/password    combination. If you pass your own client id you will not be able to use the    from_password_grant function.</li> <li>Here you can pass the client id like normal.</li> </ol>"},{"location":"getting-started-api/examples/myanimelist/#usage","title":"Usage","text":"<pre><code>from anipy_api.mal import MyAnimeList, MALMyListStatusEnum\nmal = ...\n\nfrieren = mal.get_anime(52991)\nprint(frieren.title)\n\nresults = mal.get_search( # (1)\n    \"frieren\",\n    limit=20, # (2)\n    pages=2 # (3)\n)\nprint(results)\n\nuser = mal.get_user() # (4)\nprint(user)\n\nupdated_entry = mal.update_anime_list( # (5)\n    52991,\n    status=MALMyListStatusEnum.WATCHING,\n    watched_episodes=2,\n    tags=[\"currently-updated\"] # (6)\n)\nprint(updated_entry)\n\nfrieren_now = mal.get_anime(52991) # (7)\nfrieren_now.my_list_status.tags # -&gt; [\"currently-updated\"]\n\nuser_watching = mal.get_anime_list(\n    status_filter=MALMyListStatusEnum.WATCHING # (8)\n)\nprint(user_list)\n\nmal.remove_from_anime_list(52991)\n</code></pre> <ol> <li>All these functions may also return a    MyAnimeListError on for example a http    error.</li> <li>Specify the limit per page returned.</li> <li>The number of pages returned, note that the amount of anime returned is    <code>limit * pages</code>.</li> <li>This get information about the current user.</li> <li>This function either updates or adds the anime to the user's list if it does    not already exists.</li> <li>Note that this will override all the tags already set before!</li> <li>Now that the anime is added to the list, get it again and the    <code>my_list_status</code> attribute will not be <code>None</code> anymore.</li> <li>The <code>status_filter</code> attribute filters for a user list status.</li> </ol>"},{"location":"getting-started-api/examples/myanimelist/#adapting-between-provider-anime-and-myanimelist-anime","title":"Adapting between provider anime and MyAnimeList anime","text":"<p>Ok so this is the important part. Imagaine you have a provider anime and want to add that to your myanimelist, but you do not know which mal anime that is. The MyAnimeListAdapter class can handle that for you.</p> <p>BUT this does not always work, there is a possibilty that the adapter can not match the anime, this class uses the Levenshtein Distance algorithm to calculate the similiarty between names, you can tweak its parameters and also other stuff to ensure you get a match.</p> <pre><code>from anipy_api.mal import MyAnimeListAdapter\n\nmal = ...\nprovider = ... # (1)\n\nadapter = MyAnimeListAdapter(mal, provider)\n\n# Provider -&gt; MyAnimeList\nanime = ...\nmal_anime = adapter.from_provider(\n    anime,\n    minimum_similarity_ratio=0.8, # (2)\n    use_alternative_names=True # (3)\n)\nif mal_anime is not None:\n    print(mal_anime)\n\n# MyAnimeList -&gt; Provider\nmal_anime = ...\nanime = adapter.from_myanimelist(\n    mal_anime,\n    minimum_similarity_ratio=0.8,\n    use_alternative_names=True,\n    use_filters=True # (4)\n)\nif anime is not None:\n    print(anime)\n</code></pre> <ol> <li>The provider to or from which you want to adapt.</li> <li>The minimum accepted similarity ratio. This should be a number from 0-1, 1    meaning the names are identical 0 meaning there are no identical charachters    whatsoever. If it is not met the function will return None.</li> <li>With this the alternative names will also be checked if available. This    improves chances of matching but may take longer.</li> <li>You may remember the section about filters, this argument will use filters    for the provider to cut down on possible wrong results, do note that this    will take more time.</li> </ol>"},{"location":"getting-started-api/examples/player/","title":"4. Player","text":""},{"location":"getting-started-api/examples/player/#video-playback","title":"Video Playback","text":"<p>In general there are two types of players, the ones that are run as a subprocess and the other ones. The ones run with in a subprocess base upon SubProcessPlayerBase (this bases on PlayerBase) and the other ones straight upon the PlayerBase, you have to consider that both may take different arguments!</p> <p>For all available players please check out this page or use the list_players function!</p> <pre><code>from anipy_api.player import get_player\nfrom anipy_api.anime import Anime\nfrom anipy_api.provider import ProviderStream, LanguageTypeEnum\n\ndef on_play(anime: Anime, stream: ProviderStream):\n    print(\"Now playing episode {stream.episode} from {anime.name}!\")\n\nmpv_player = get_player( # (1)\n    \"/usr/bin/mpv\",\n    extra_args=[\"--fs\"],\n    play_callback=on_play\n)\n\nanime = ...\nstream = anime.get_video(\n    episode=1,\n    lang=LanguageTypeEnum.SUB,\n    preferred_quality=\"worst\"\n)\n\nmpv_player.play_title(anime, stream)\nmpv_player.wait()\nmpv_player.play_file(\"/some/file.mp4\") # (2)\n</code></pre> <ol> <li>You can also use the list_players function to get a list of players.</li> <li>With the play_file function you can play local files.</li> </ol> <p>You can also use the mpv-controllable player, it wraps the python-mpv  player which uses libmpv, check python-mpv's readme to know how to get libmpv. This allows you to controll the player in the code, check this out: <pre><code>from anipy_api.player import get_player, list_players\nfrom anipy_api.anime import Anime\nfrom anipy_api.provider import ProviderStream, LanguageTypeEnum\n\ndef on_play(anime: Anime, stream: ProviderStream):\n    print(\"Now playing episode {stream.episode} from {anime.name}!\")\n\nmpv_controllable_player = get_player(\n    \"mpv-controllable\",\n    play_callback=on_play \n    # (1)\n)\n\nanime = ...\nstream = anime.get_video(\n    episode=1,\n    lang=LanguageTypeEnum.SUB,\n    preferred_quality=\"worst\"\n)\n\nmpv_controllable_player.play_title(anime, stream)\nmpv_player.mpv.seek(10) # (2)\nmpv_player.wait()\n</code></pre></p> <ol> <li>This player does not accept the extra_args argument, but it does allow you to override arguments passed to the MPV object, for that use the MpvControllable class directly.</li> <li>This, for example, seeks the player by 10 seconds. Check out the other functions of the controllable mpv instance in the python-mpv repo or use your LSP!</li> </ol>"},{"location":"getting-started-api/examples/provider/","title":"1. Provider","text":""},{"location":"getting-started-api/examples/provider/#what-is-a-provider","title":"What is a provider?","text":"<p>A provider in anipy-api is the building stone that connects us to the anime we want! A provder may be a external anime site or even your local files (this is planned, Coming Soon!). Every provider bases on the BaseProvider and has the same basic functions: <code>get_search</code>, <code>get_episodes</code>, <code>get_info</code> and <code>get_video</code>.</p> <p>You can check which providers anipy-cli supports here or here (in the <code>providers</code> drop-down).</p>"},{"location":"getting-started-api/examples/provider/#getting-a-provider-instance","title":"Getting a provider instance","text":"<p>To get a provider you can use the list_providers function, get_provider to get a provider by its string representation or just simply import it directly.</p> <pre><code>from anipy_api.provider import list_providers, get_provider \n\n\n# List providers\nfor p in list_providers():\n    if p.NAME == \"gogoanime\":\n        # You have to instantiate the provider to use it.\n        provider = provider()\n\n# If you know the name of the provider you could also do:\nprovider = get_provider(\"gogoanime\", base_url_override=\"https://test.com\") #(1)\n\n# You can also import\nfrom anipy_api.provider.providers import GoGoProvider\nprovider = GoGoProvider()\n\nprint(provider.NAME) # -&gt; gogoanime\nprint(provider.BASE_URL) # -&gt; https://test.com\n</code></pre> <ol> <li>Furthermore, you can specify a url override for each provider!</li> </ol>"},{"location":"getting-started-api/examples/provider/#searching","title":"Searching","text":"<p>Searching can be done with the get_search method, you can even filter! <pre><code>results = provider.get_search(\"frieren\") # (1)\n</code></pre></p> <ol> <li>Just FYI, we are using the same provider we got in the above example!</li> </ol> <p>This returns a list of ProviderSearchResult objects. Each contains the identifier of the anime, the name and a set of language types the anime supports. The language type set tells you if the anime supports dub/sub format.</p>"},{"location":"getting-started-api/examples/provider/#filtering","title":"Filtering","text":"<p>Every provider has a <code>FILTER_CAPS</code> attribute, it specifies which filters the provider supports. <pre><code>from anipy_api.provider import Filters, FilterCapabilities, Season\n\nif provider.FILTER_CAPS &amp; ( # (1)\n    FilterCapabilities.SEASON\n    | FilterCapabilities.YEAR\n    | FilterCapabilities.NO_QUERY # (2)\n):\n    filters = Filters( # (3)\n        year=2023,\n        season=Season.FALL,\n    )\n    fall_2023_anime = provider.get_search(\"\", filters=filters) # (4)\n</code></pre></p> <ol> <li>You can use bitwise operators here because this is a Flag class, check out the offical documentation, you may also use the <code>in</code> keyword.</li> <li>If a provider supports NO_QUERY it means that if you search without query you get all available anime in its database.</li> <li>If you use filters not supported by the provider, they will get skipped, no error will be raised.</li> <li>Here we search without query, because we want to get all the anime available that are in the fall season of 2023.</li> </ol>"},{"location":"getting-started-api/examples/provider/#putting-it-all-together","title":"Putting it all together","text":"<pre><code>from anipy_api.provider import get_provider \n\nprovider = get_provider(\"gogoanime\")\nfrieren = provider.get_search(\"frieren\")[0]\n\nif provider.FILTER_CAPS &amp; (\n    FilterCapabilities.SEASON\n    | FilterCapabilities.YEAR\n    | FilterCapabilities.NO_QUERY\n):\n    filters = Filters(\n        year=2023,\n        season=Season.FALL,\n    )\n    fall_2023_anime = provider.get_search(\"\", filters=filters)\n\n    if frieren in fall_2023_anime:\n        print(\"Frieren is an fall 2023 anime!\") \n</code></pre>"},{"location":"getting-started-api/examples/provider/#thats-about-it-here","title":"Thats about it here","text":"<p>But... <code>get_episodes</code>, <code>get_info</code> and <code>get_video</code> were not covered!</p> <p>Those are covered in the second example page 2. Anime. The next page describes a wrapper for the search results that represents an anime, you can still use the functions directly from the provider but you would probably use them in the Anime class, but feel free to do it how you want!</p>"},{"location":"getting-started-cli/","title":"Getting started with the CLI","text":""},{"location":"getting-started-cli/#installation","title":"Installation","text":""},{"location":"getting-started-cli/#pre-requesits","title":"Pre-requesits","text":"<ul> <li>Python (3.9 higher, this is not tested ;) but I think that this is the case). If you are on windows avoid the python from the Microsoft Store and use the official one linked.</li> <li>Pip</li> <li>Pipx (optional, but very much recommended, I mean it, get this)</li> <li>mpv or any other player listed here, but I strongly recommended mpv or a derivative because it \u2728 just works \u2728.</li> <li>FFmpeg (optional, but again, I recommend it because without it you can not use some features)</li> </ul>"},{"location":"getting-started-cli/#options-to-install","title":"Options to install","text":"<ul> <li>Recommended: Via pipx <pre><code># Install\npipx install anipy-cli\n\n# Update\npipx upgrade anipy-cli\n\n# Uninstall\npipx uninstall anipy-cli\n</code></pre></li> <li>Via pipx (from source):  <pre><code># Install\npipx install \"git+https://github.com/sdaqo/anipy-cli.git#subdirectory=cli\"\n\n# Update\npipx upgrade anipy-cli\n\n# Uninstall\npipx uninstall anipy-cli\n</code></pre></li> <li>Via pip:  <pre><code># Install\npip install anipy-cli\n\n# Update\npip --upgrade anipy-cli\n\n# Uninstall\npip uninstall anipy-cli\n</code></pre></li> <li>Via pip (from source):  <pre><code># Install\npip install \"git+https://github.com/sdaqo/anipy-cli.git#subdirectory=cli\"\n\n# Update\npip --upgrade anipy-cli\n\n# Uninstall\npip uninstall anipy-cli\n</code></pre></li> <li>NixOS:  <pre><code># Make sure you have flakes enabled on your system!\n\n# Just run it once to try the program\nnix run github:sdaqo/anipy-cli\n\n# Add them to your flake inputs (recommended)\n# \n# {\n#   anipy-cli.url = \"github:sdaqo/anipy-cli\";\n# }\n#\n# Use it with inputs.anipy-cli.${pkgs.system}.default\n# For example:\n#\n# environment.systemPackages = [\n#  inputs.anipy-cli.packages.${pkgs.system}.default\n# ];\n\n# Via Profile\nnix profile install github:sdaqo/anipy-cli\nnix profile update github:sdaqo/anipy-cli\nnix profile list # Get the index of anipy-cli\nnix profile remove &lt;index-of-anipy-cli&gt;\n</code></pre></li> </ul>"},{"location":"getting-started-cli/#usage","title":"Usage","text":"Explainations for non-obvious stuffHelp Output <p>This is just a paste from <code>anipy-cli --help</code>. <pre><code>usage: anipy-cli [-D | -B | -H | -S | -M | -A | --delete-history | --migrate-history] [-s SEARCH] [-ss [SEASONAL_SEARCH]]\n                 [-q QUALITY] [-f] [-a] [-p {mpv,vlc,iina,syncplay,mpvnet,mpv-controlled}] [-l LOCATION] [-V]\n                 [--stack-always] [-so] [--mal-password MAL_PASSWORD] [--mal-sync-to-seasonals]\n                 [--anilist-sync-to-seasonals] [-h] [-v] [--config-path]\n\nPlay Animes from online anime providers locally or download them, and much more.\n\nActions:\n  Different Actions and Modes of anipy-cli (only pick one)\n\n  -D, --download        Download mode. Download multiple episodes like so: first_number-second_number (e.g. 1-3)\n  -B, --binge           Binge mode. Binge multiple episodes like so: first_number-second_number (e.g. 1-3)\n  -H, --history         Show your history of watched anime\n  -S, --seasonal        Seasonal Anime mode. Bulk download or binge watch newest episodes.\n  -M, --my-anime-list   MyAnimeList mode. Similar to seasonal mode, but using MyAnimeList (requires MAL account\n                        credentials to be set in config).\n  -A, --anilist         Anilist mode. Similar to seasonal mode, but using Anilist\n  --delete-history      Delete your History.\n  --migrate-history     Migrate your history to the current provider.\n\nOptions:\n  Options to change the behaviour of anipy-cli\n\n  -s SEARCH, --search SEARCH\n                        Provide a search term to Default, Download or Binge mode in this format: {query}:{episode\n                        range}:{dub/sub}. Examples: 'frieren:1-10:sub' or 'frieren:1:sub' or 'frieren:1-3 7-12:dub', this\n                        argument may be appended to any of the modes mentioned like so: 'anipy-cli (-D/B) -s &lt;search&gt;'\n  -ss [SEASONAL_SEARCH], --seasonal-search [SEASONAL_SEARCH]\n                        Provide search parameters for seasons to Default, Download, or Binge mode in this format:\n                        {year}:{season}. You can only use part of the season name if you wish. Examples: '2024:win' or\n                        '2020:fa'\n  -q QUALITY, --quality QUALITY\n                        Change the quality of the video, accepts: best, worst or 360, 480, 720 etc. Default: best\n  -f, --ffmpeg          Use ffmpeg to download m3u8 playlists, may be more stable but is way slower than internal\n                        downloader\n  -a, --auto-update     Automatically update and download all Anime in seasonals or mal mode from start EP to newest.\n  -p {mpv,vlc,iina,syncplay,mpvnet,mpv-controlled}, --optional-player {mpv,vlc,iina,syncplay,mpvnet,mpv-controlled}\n                        Override the player set in the config.\n  -l LOCATION, --location LOCATION\n                        Override all configured download locations\n  -V, --verbose         Verbosity levels in the console: -V = 'fatal' -VV = 'warnings' -VVV = 'info'\n  --stack-always        Always show the stack trace on any log outputs.\n  -so, --sub-only       Download only subtitles\n  --mal-password MAL_PASSWORD\n                        Provide password for MAL login (overrides password set in config)\n  --mal-sync-to-seasonals\n                        Automatically sync myanimelist to seasonals (only works with `-M`)\n  --anilist-sync-to-seasonals\n                        Automatically sync anilist to seasonals (only works with `-A`)\n\nInfo:\n  Info about the current anipy-cli installation\n\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  --config-path         Print path to the config file.\n</code></pre></p>"},{"location":"getting-started-cli/#seasonal-mode","title":"Seasonal Mode","text":"<p>Seasonal Mode is one of the major modes of anipy-cli, with it you can manage your weekly dose of anime. Every new anime season you can add your anime you want to watch and check back every week to see if there are any new episodes!</p> <p>Info</p> <p>All major modes are listed under <code>Actions</code> in <code>anipy-cli --help</code>, you can only pick one of them.</p>"},{"location":"getting-started-cli/#check-out-the-main-menu-of-seasonal-mode","title":"Check out the main menu of seasonal mode:","text":"<p><pre><code>[a] Add Anime\n[e] Delete one anime from seasonals\n[l] List anime in seasonals\n[c] Change dub/sub of anime in seasonals\n[d] Download newest episodes\n[w] Binge watch newest episodes\n[q] Quit\nEnter option:\n</code></pre> All these options should be pretty self-explanatory.</p>"},{"location":"getting-started-cli/#myanimelistanilist-mode","title":"MyAnimeList/AniList Mode","text":"<p>The two tracker Modes are major modes of anipy-cli. The modes is similar to the seasonal mode but it uses your online anime tracker list instead.</p>"},{"location":"getting-started-cli/#where-do-i-put-my-login","title":"Where do I put my login?","text":"<p>There are several options:</p> <ul> <li>Always login through the cli prompt.</li> <li>Set username and password in the config for MyAnimeList</li> <li>Set anilist token in config as <code>anilist_token</code> for AnList, this can be obtained when logging in via the cli for the first time.</li> <li>Set the username in the config and pass the password via the <code>--mal-password</code> option. (only MyAnimeList)</li> </ul>"},{"location":"getting-started-cli/#anime-tagging-in-trackers","title":"Anime Tagging in Trackers","text":"<p>You can tag (either via the cli using the <code>t</code> option or directly in the tracker itself) your anime with a dub and a ignore tag. You can define the name of those tags in the config, the defaults are <code>dub</code> and <code>ignore</code>.</p> dub This tag makes the anime play/download in dub within the tracker modes. ignore With this tag the anime will be completely ignored by the tracker modes."},{"location":"getting-started-cli/#check-out-the-main-menu-of-mal-mode-anilist-mode-is-basically-identical","title":"Check out the main menu of MAL mode. (AniList mode is basically identical)","text":"<pre><code>[a] Add Anime\n[e] Delete one anime from MyAnimeList\n[l] List anime in MyAnimeList\n[t] Tag anime in MyAnimeList (dub/ignore)\n[m] Map MyAnimeList anime to providers\n[s] Sync MyAnimeList into seasonals\n[b] Sync seasonals into MyAnimeList\n[d] Download newest episodes\n[x] Download all episodes\n[w] Binge watch newest episodes\n[q] Quit\nEnter option:\n</code></pre> <p>Note</p> <p>This explanation applies to AniList and MyAnimeList</p> <p>The <code>m</code> option is very important it syncs the MyAnimeList anime to provider animeso we can actually get videos for the anime. You will be prompted for this anyway so do not worry to much, but it helps to run this every once in a while.</p> <p>The <code>s</code> option syncs all the anime in the status catagories specified in the config as <code>mal_status_catagories</code> to the seasonls, including episodes left of etc.</p> <p>The <code>b</code> option is the same as <code>s</code> but in the other direction.</p> <p>The <code>x</code> downloads all of the episodes instead of only the non-watched ones. This is pretty nice if you want to sync all the anime to your local disk, just run it once in a while (maybe even with Auto Update) to keep everything in-sync, it will skip already downloaded ones.</p>"},{"location":"getting-started-cli/#auto-update","title":"Auto Update","text":"<p>Auto update is a flag in anipy-cli: <code>--auto-update</code> it will automatically update and download all anime in seasonals or mal mode from start episode to newest. This is increadibly handy if you want to set up some cron job to keep your library up-to-date.</p> <p>Note</p> <p>This only works in combination with <code>-M</code> or <code>-S</code></p> <p>Here is a example for a cron job: <pre><code># Cronjob runs every 2 minutes and checks whether anipy-cli is still running or not\n# (only run the job if last one is finished)\n\n*/2 *   * * *   username        pidof -x anipy-cli || anipy-cli -Ma &gt;&gt; /var/log/anipy-cli.log\n</code></pre></p>"},{"location":"getting-started-cli/#other-weird-options","title":"Other weird options","text":"<code>--mal-sync-to-seasonals</code> / <code>--anilist-sync-to-seasonals</code> This options just automatically executes the <code>s</code> option in the MAL mode menu. Useful for automation. <code>--ffmpeg</code> This makes the downloader default the ffmpeg (except for .mp4 files), ffmpeg must be installed."},{"location":"getting-started-cli/#native-provider","title":"Native Provider","text":"<p>The native provider uses a directory on your filesystem to build an anime database that can be used in the cli. To use it, set your provider to <code>native</code> and set the provider url for the native provider to your anime directory! The implementation is very basic. Your folder structure is not really important, both a flat directory and a directory with season subdirectories works. What is important, is that, your files should sort properly, episodes numbers are assigned based on the alphabetical order of files in a directory.</p>"},{"location":"getting-started-cli/#config","title":"Config","text":""},{"location":"getting-started-cli/#config-locations-normally-better-use-config-path","title":"Config Locations (normally, better use <code>--config-path</code>):","text":"<ul> <li>Linux/Unix: ~/.config/anipy-cli/config.yaml</li> <li>MacOS: /Library/Application Support/anipy-cli/config.yaml</li> <li>Windows: C:\\Users\\%USERPROFILE%\\AppData\\Local\\anipy-cli</li> </ul> <p>For convinience's sake there is a extra cli option that gives you the config path:</p> <pre><code>anipy-cli --config-path\n/path/to/your/config.yaml\n</code></pre>"},{"location":"getting-started-cli/#configuring","title":"Configuring","text":"<p>All the options should be documented with comments, please use those as reference, if you are confused just open an issue!</p>"},{"location":"getting-started-cli/#features","title":"Features","text":"<ul> <li>Faster than watching in the browser.</li> <li>Play Animes in Your Local video player</li> <li>Select a quality in which the video will be played/downloaded.</li> <li>Download Animes</li> <li>History of watched Episodes</li> <li>Binge Mode to watch a range of episodes back-to-back.</li> <li>Seasonal Mode to bulk download or binge watch the latest episodes of animes   you pick</li> <li>Configurable with config</li> <li>MAL Mode: Like seasonal mode, but uses your anime list at   MyAnimeList.net</li> <li>AniList Mode: Like seasonal mode, but uses your anime list at   anilist.co</li> <li>Discord Presence for the anime you currently watch. This is off by default,   activate it in the config.</li> <li>Native filesystem provider, turn your anime directory into a anime cli</li> </ul>"},{"location":"reference/","title":"API Code Reference","text":"<p>Not to much to say, please enjoy the code reference!</p> <p>If you are not sure what you are looking at or are confused check out the examples in the Getting Started - API section or if you are still stuck please open an issue on github!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>API Code Reference</li> <li>anipy_api<ul> <li>anilist</li> <li>anime</li> <li>download</li> <li>error</li> <li>locallist</li> <li>mal</li> <li>player<ul> <li>base</li> <li>player</li> <li>players<ul> <li>iina</li> <li>mpv</li> <li>mpv_control</li> <li>syncplay</li> <li>vlc</li> </ul> </li> </ul> </li> <li>provider<ul> <li>base</li> <li>filter</li> <li>provider</li> <li>providers<ul> <li>allanime_provider</li> <li>animekai_provider</li> <li>native_provider</li> </ul> </li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/anipy_api/anilist/","title":"anilist","text":""},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList","title":"<code>AniList(client_id=None)</code>","text":"<p>MyAnimeList api client that implements some of the endpoints documented here.</p> <p>Attributes:</p> Name Type Description <code>API_BASE</code> <p>The base url of the api (https://api.myanimelist.net/v2)</p> <code>CLIENT_ID</code> <p>The client being used to access the api</p> <code>RESPONSE_FIELDS</code> <p>Corresponds to fields of AniListAnime object (read here for explaination)</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>Optional[str]</code> <p>Overrides the default client id</p> <code>None</code> Info <p>Please note that that currently no complex oauth autentication scheme is implemented, this client uses the client id of the official MyAnimeList android app, this gives us the ability to login via a username/password combination. If you pass your own client id you will not be able to use the from_implicit_grant function.</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def __init__(self, client_id: Optional[str] = None):\n    \"\"\"__init__ of AniList.\n\n    Args:\n        client_id: Overrides the default client id\n\n    Info:\n        Please note that that currently no complex oauth autentication scheme is\n        implemented, this client uses the client id of the official MyAnimeList\n        android app, this gives us the ability to login via a username/password\n        combination. If you pass your own client id you will not be able to use\n        the [from_implicit_grant][anipy_api.anilist.AniList.from_implicit_grant] function.\n    \"\"\"\n    if client_id:\n        self.CLIENT_ID = client_id\n        self.AUTH_URL = f\"https://anilist.co/api/v2/oauth/authorize?client_id={self.CLIENT_ID}&amp;response_type=token\"\n\n    self._access_token = None\n    self._auth_expire_time = datetime.datetime.min\n    self._session = Session()\n    self._session.headers.update(\n        {\n            \"Content-Type\": \"application/json\", \n            \"Accept\": \"application/json\",\n        }\n    )\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.from_implicit_grant","title":"<code>from_implicit_grant(access_token, client_id=None)</code>  <code>staticmethod</code>","text":"<p>Authenticate via Implicit Grant to retrieve access token</p> <p>Returns:</p> Type Description <code>AniList</code> <p>The AniList client object</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>@staticmethod\ndef from_implicit_grant(\n    access_token: str,\n    client_id: Optional[str] = None\n) -&gt; \"AniList\":\n    \"\"\"Authenticate via Implicit Grant to retrieve access token\n\n    Returns:\n        The AniList client object\n    \"\"\"\n    anilist = AniList(client_id)\n    anilist._refresh_auth(access_token)\n    return anilist\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.get_anime","title":"<code>get_anime(anime_id)</code>","text":"<p>Get a MyAnimeList anime by its id.</p> <p>Parameters:</p> Name Type Description Default <code>anime_id</code> <code>int</code> <p>The id of the anime</p> required <p>Returns:</p> Type Description <code>AniListAnime</code> <p>The anime that corresponds to the id</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def get_anime(self, anime_id: int) -&gt; AniListAnime:\n    \"\"\"Get a MyAnimeList anime by its id.\n\n    Args:\n        anime_id: The id of the anime\n\n    Returns:\n        The anime that corresponds to the id\n    \"\"\"\n    query = \"\"\"\n    query ($id: Int) {\n      Media (id: $id) {\n        id\n        media_type: format\n        num_episodes: episodes\n        title {\n          user_preferred: userPreferred\n        }\n        alternative_titles: title {\n          english\n          native\n          romaji\n        }\n        year: seasonYear\n        season\n        my_list_status: mediaListEntry {\n          entry_id: id\n          notes\n          num_episodes_watched: progress\n          status\n          score\n        }\n      }\n    }\n    \"\"\"\n    variables = { \"id\": anime_id }\n    request = Request(\"POST\", self.API_BASE, json={ 'query': query, 'variables': variables })\n    return AniListAnime.from_dict(self._make_request(request)[\"data\"][\"Media\"])\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.get_anime_list","title":"<code>get_anime_list(status_filter=None)</code>","text":"<p>Get the anime list of the currently authenticated user.</p> <p>Parameters:</p> Name Type Description Default <code>status_filter</code> <code>Optional[AniListMyListStatusEnum]</code> <p>A filter that determines which list status is retrieved</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AniListAnime]</code> <p>List of anime in the anime list</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def get_anime_list(\n    self, status_filter: Optional[AniListMyListStatusEnum] = None\n) -&gt; List[AniListAnime]:\n    \"\"\"Get the anime list of the currently authenticated user.\n\n    Args:\n        status_filter: A filter that determines which list status is retrieved\n\n    Returns:\n        List of anime in the anime list\n    \"\"\"\n    query = \"\"\"\n    query ($type: MediaType!, $userId: Int!) {\n      MediaListCollection(type: $type, userId: $userId) {\n        lists {\n          entries {\n            id\n            media {\n              id\n              media_type: format\n              num_episodes: episodes\n              title {\n                  user_preferred: userPreferred\n              }\n              alternative_titles: title {\n                  english\n                  native\n                  romaji\n              }\n              year: seasonYear\n                season\n                my_list_status: mediaListEntry {\n                  entry_id: id\n                  notes\n                  num_episodes_watched: progress\n                  status\n                  score\n                }\n            }\n          }\n        }\n      }\n    }\n    \"\"\"\n    user_id = self.get_user().id\n    variables = { \"type\": \"ANIME\", \"userId\": user_id }\n    request = Request(\"POST\", self.API_BASE, json={ 'query': query, 'variables': variables })\n\n    anime_list = []\n    for group in self._make_request(request)[\"data\"][\"MediaListCollection\"][\"lists\"]:\n        for entry in group[\"entries\"]:\n            anime = AniListAnime.from_dict(entry[\"media\"])\n            user_status = anime.my_list_status.status if anime.my_list_status else None\n            if status_filter is None or user_status == status_filter:\n                anime_list.append(anime)\n\n    return anime_list\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.get_search","title":"<code>get_search(search, limit=20, pages=1)</code>","text":"<p>Search AniList.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>str</code> <p>Search query</p> required <code>limit</code> <code>int</code> <p>The amount of results per page</p> <code>20</code> <code>pages</code> <code>int</code> <p>The amount of pages to return, note the total number of results is limit times pages</p> <code>1</code> <p>Returns:</p> Type Description <code>List[AniListAnime]</code> <p>A list of search results</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def get_search(self, search: str, limit: int = 20, pages: int = 1) -&gt; List[AniListAnime]:\n    \"\"\"Search AniList.\n\n    Args:\n        search: Search query\n        limit: The amount of results per page\n        pages: The amount of pages to return,\n            note the total number of results is limit times pages\n\n    Returns:\n        A list of search results\n    \"\"\"\n    query = \"\"\"\n    query ($search: String!, $page: Int, $perPage: Int) {\n      Page (page: $page, perPage: $perPage){\n      page_info: pageInfo {\n          currentPage\n          hasNextPage\n      }\n      media (search: $search, type: ANIME) {\n      id\n      media_type: format\n      num_episodes: episodes\n      title {\n        user_preferred: userPreferred\n      }\n      alternative_titles: title {\n        english\n        native\n        romaji\n      }\n      year: seasonYear\n      season\n      my_list_status: mediaListEntry {\n            entry_id: id\n            notes\n            num_episodes_watched: progress\n            status\n            score\n          }\n        }\n      }\n    }\n    \"\"\"\n\n    anime_list = []\n    next_page = True\n\n    for page in range(pages):\n        if next_page:\n            variables = { \"search\": search, \"page\": page+1, \"perPage\": limit }\n            request = Request(\"POST\", self.API_BASE, json={ 'query': query, 'variables': variables })\n            response = AniListPagingResource.from_dict(self._make_request(request)[\"data\"][\"Page\"])\n            anime_list.extend(response.media)\n\n            next_page = response.page_info.has_next_page\n\n    return anime_list\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.get_user","title":"<code>get_user()</code>","text":"<p>Get information about the currently authenticated user.</p> <p>Returns:</p> Type Description <code>AniListUser</code> <p>A object with user information</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def get_user(self) -&gt; AniListUser:\n    \"\"\"Get information about the currently authenticated user.\n\n    Returns:\n        A object with user information\n    \"\"\"\n    query=\"\"\"\n    query {\n      Viewer {\n        id\n        name\n        picture: avatar {\n              large\n              medium\n        }\n      }\n    }\n    \"\"\"\n    request = Request(\n            \"POST\", self.API_BASE, json={ 'query': query }\n    )\n    return AniListUser.from_dict(self._make_request(request)[\"data\"][\"Viewer\"])\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.remove_from_anime_list","title":"<code>remove_from_anime_list(anime_id)</code>","text":"<p>Remove an anime from the currently authenticated user's anime list.</p> <p>Parameters:</p> Name Type Description Default <code>anime_id</code> <code>int</code> <p>Id of the anime to be removed</p> required Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def remove_from_anime_list(self, anime_id: int):\n    \"\"\"Remove an anime from the currently authenticated user's anime list.\n\n    Args:\n        anime_id: Id of the anime to be removed\n    \"\"\"\n    query = \"\"\"\n    mutation ($listEntryId: Int!) {\n      DeleteMediaListEntry(id: $listEntryId) {\n        deleted\n      }\n    }\n    \"\"\"\n    my_list_status = self.get_anime(anime_id).my_list_status\n    if my_list_status:\n        list_entry_id = my_list_status.entry_id\n        variables = { \"listEntryId\": list_entry_id }\n        request = Request(\"POST\", self.API_BASE, json={ 'query': query, 'variables': variables})\n        self._make_request(request)\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniList.update_anime_list","title":"<code>update_anime_list(anime_id, status=None, watched_episodes=None, tags=None)</code>","text":"<p>Update a specific anime in the currently authenticated users's anime list. Only pass the arguments you want to update.</p> <p>Parameters:</p> Name Type Description Default <code>anime_id</code> <code>int</code> <p>The anime id of the anime to update</p> required <code>status</code> <code>Optional[AniListMyListStatusEnum]</code> <p>Updated status of the anime</p> <code>None</code> <code>watched_episodes</code> <code>Optional[int]</code> <p>Updated watched episodes</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Updated list of tags, note that this ovewrites the already existing tags, if you want to retain the old ones you have to merge the old ones with the new ones yourself.</p> <code>None</code> <p>Returns:</p> Type Description <code>AniListMyListStatus</code> <p>Object of the updated anime</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def update_anime_list(\n    self,\n    anime_id: int,\n    status: Optional[AniListMyListStatusEnum] = None,\n    watched_episodes: Optional[int] = None,\n    tags: Optional[List[str]] = None,\n) -&gt; AniListMyListStatus:\n    \"\"\"Update a specific anime in the currently authenticated users's anime\n    list. Only pass the arguments you want to update.\n\n    Args:\n        anime_id: The anime id of the anime to update\n        status: Updated status of the anime\n        watched_episodes: Updated watched episodes\n        tags: Updated list of tags, note that this **ovewrites** the already\n            existing tags, if you want to retain the old ones you have to merge\n            the old ones with the new ones yourself.\n\n    Returns:\n        Object of the updated anime\n    \"\"\"\n    query = \"\"\"\n    mutation ($listEntryId: Int, $status: MediaListStatus, $episodes: Int, $notes: String) {\n      SaveMediaListEntry(id: $listEntryId, status: $status, progress: $episodes, notes: $notes) {\n        entry_id: id\n        notes\n        num_episodes_watched: progress\n        status\n        score\n      }\n    }\n    \"\"\"\n    my_list_status = self.get_anime(anime_id).my_list_status\n    if not my_list_status:\n        raise ValueError(f\"No existing list entry found for anime ID {anime_id}.\")\n    list_entry_id = my_list_status.entry_id\n    variables = {\n        k: v\n        for k, v in {\n            \"listEntryId\": list_entry_id,\n            \"status\": status.value if status else None,\n            \"num_watched_episodes\": watched_episodes,\n            \"tags\": \",\".join(tags) if tags is not None else None,\n        }.items()\n        if v is not None\n    }\n    request = Request(\"POST\", self.API_BASE, json={ 'query': query, 'variables': variables })\n\n    return AniListMyListStatus.from_dict(self._make_request(request)[\"data\"][\"SaveMediaListEntry\"])\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListAdapter","title":"<code>AniListAdapter(myanimelist, provider)</code>","text":"<p>A adapter class that can adapt MyAnimeList anime to Provider anime.</p> <p>Attributes:</p> Name Type Description <code>anilist</code> <code>AniList</code> <p>The AniList object</p> <code>provider</code> <code>BaseProvider</code> <p>The provider object</p> <p>Parameters:</p> Name Type Description Default <code>anilist</code> <p>The AniList object to use</p> required <code>provider</code> <code>BaseProvider</code> <p>The provider object to use</p> required Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def __init__(self, myanimelist: AniList, provider: \"BaseProvider\") -&gt; None:\n    \"\"\"__init__ of MyAnimeListAdapter.\n\n    Args:\n        anilist: The AniList object to use\n        provider: The provider object to use\n    \"\"\"\n    self.anilist: AniList = myanimelist\n    self.provider: \"BaseProvider\" = provider\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListAdapter.from_anilist","title":"<code>from_anilist(anilist_anime, minimum_similarity_ratio=0.8, use_filters=True, use_alternative_names=True)</code>","text":"<p>Adapt an anime from a AniListAnime to a provider Anime. This uses Levenshtein Distance to calculate the similarity of names.</p> <p>Parameters:</p> Name Type Description Default <code>anilist_anime</code> <code>AniListAnime</code> <p>The anilist anime to adapt from</p> required <code>minimum_similarity_ratio</code> <code>float</code> <p>The minimum accepted similarity ratio. This should be a number from 0-1, 1 meaning the names are identical 0 meaning there are no identical charachters whatsoever. If it is not met the function will return None.</p> <code>0.8</code> <code>use_filters</code> <code>bool</code> <p>Use filters for the provider to cut down on possible wrong results, do note that this will take more time.</p> <code>True</code> <code>use_alternative_names</code> <code>bool</code> <p>Use alternative names for matching, this may yield a higher chance of finding a match but takes more time.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Anime]</code> <p>A Anime object if adapting was successfull</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def from_anilist(\n    self,\n    anilist_anime: AniListAnime,\n    minimum_similarity_ratio: float = 0.8,\n    use_filters: bool = True,\n    use_alternative_names: bool = True,\n) -&gt; Optional[Anime]:\n    \"\"\"Adapt an anime from a [AniListAnime][anipy_api.anilist.AniListAnime] to a provider [Anime][anipy_api.anime.Anime].\n    This uses [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) to calculate the similarity of names.\n\n    Args:\n        anilist_anime: The anilist anime to adapt from\n        minimum_similarity_ratio: The minimum accepted similarity ratio. This should be a number from 0-1,\n            1 meaning the names are identical 0 meaning there are no identical charachters whatsoever.\n            If it is not met the function will return None.\n        use_filters: Use filters for the provider to cut down on possible wrong results, do note that this will take more time.\n        use_alternative_names: Use alternative names for matching, this may yield a higher chance of finding a match but takes more time.\n\n    Returns:\n        A Anime object if adapting was successfull\n\n    \"\"\"\n    anilist_titles = {anilist_anime.title.user_preferred}\n    if use_alternative_names and anilist_anime.alternative_titles is not None:\n        anilist_titles |= {\n            t\n            for t in [\n                anilist_anime.alternative_titles.native,\n                anilist_anime.alternative_titles.english,\n                anilist_anime.alternative_titles.romaji\n            ]\n            if t is not None\n        }\n\n    provider_filters = Filters()\n    if (\n        self.provider.FILTER_CAPS &amp; FilterCapabilities.YEAR\n        and anilist_anime.season is not None\n    ):\n        provider_filters.year = anilist_anime.year\n\n    if (\n        self.provider.FILTER_CAPS &amp; FilterCapabilities.SEASON\n        and anilist_anime.season is not None\n    ):\n        provider_filters.season = Season[\n            anilist_anime.season.value.upper()\n        ]\n\n    if self.provider.FILTER_CAPS &amp; FilterCapabilities.MEDIA_TYPE:\n        if anilist_anime.media_type == AniListMediaTypeEnum.TV_SHORT:\n            m_type = AniListMediaTypeEnum.TV\n        else:\n            m_type = anilist_anime.media_type\n\n        provider_filters.media_type = MediaType[m_type.value.upper()]\n\n    results: Set[ProviderSearchResult] = set()\n    for title in anilist_titles:\n        if len(title) == 0:\n            continue\n\n        results |= set(self.provider.get_search(title))\n        if use_filters:\n            results |= set(self.provider.get_search(title, provider_filters))\n\n    best_ratio = 0\n    best_anime = None\n    for r in results:\n        anime = Anime.from_search_result(self.provider, r)\n        provider_titles = {anime.name}\n\n        if use_alternative_names:\n            anime_info = anime.get_info()\n            if anime_info.release_year == anilist_anime.year:\n                provider_titles |= set(anime_info.alternative_names or [])\n            else:\n                continue\n\n        ratio = self._find_best_ratio(anilist_titles, provider_titles)\n\n        if ratio &gt; best_ratio:\n            best_ratio = ratio\n            best_anime = anime\n        elif (\n            best_anime is not None\n            and ratio == best_ratio\n            and len(anime.languages) &gt; len(best_anime.languages)\n        ):\n            # prefer anime with more language options\n            best_anime = anime\n\n        if best_ratio == 1:\n            break\n\n    if best_ratio &gt; minimum_similarity_ratio:\n        return best_anime\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListAdapter.from_provider","title":"<code>from_provider(anime, minimum_similarity_ratio=0.8, use_alternative_names=True)</code>","text":"<p>Adapt an anime from provider Anime to a AniListAnime. This uses Levenshtein Distance to calculate the similarity of names.</p> <p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Anime</code> <p>The anime to adapt from</p> required <code>minimum_similarity_ratio</code> <code>float</code> <p>The minimum accepted similarity ratio. This should be a number from 0-1, 1 meaning the names are identical 0 meaning there are no identical charachters whatsoever. If it is not met the function will return None.</p> <code>0.8</code> <code>use_alternative_names</code> <code>bool</code> <p>Use alternative names for matching, this may yield a higher chance of finding a match but takes more time.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[AniListAnime]</code> <p>A AniListAnime object if adapting was successfull</p> Source code in <code>api/src/anipy_api/anilist.py</code> <pre><code>def from_provider(\n    self,\n    anime: Anime,\n    minimum_similarity_ratio: float = 0.8,\n    use_alternative_names: bool = True,\n) -&gt; Optional[AniListAnime]:\n    \"\"\"Adapt an anime from provider [Anime][anipy_api.anime.Anime] to a [AniListAnime][anipy_api.anilist.AniListAnime].\n    This uses [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) to calculate the similarity of names.\n\n    Args:\n        anime: The anime to adapt from\n        minimum_similarity_ratio: The minimum accepted similarity ratio. This should be a number from 0-1,\n            1 meaning the names are identical 0 meaning there are no identical charachters whatsoever.\n            If it is not met the function will return None.\n        use_alternative_names: Use alternative names for matching, this may yield a higher chance of finding\n            a match but takes more time.\n\n    Returns:\n        A AniListAnime object if adapting was successfull\n    \"\"\"\n    results = self.anilist.get_search(anime.name)\n\n    best_anime = None\n    best_ratio = 0\n    for i in results:\n        titles_mal = {i.title.user_preferred}\n        titles_provider = {anime.name}\n\n        if use_alternative_names:\n            if i.alternative_titles is not None:\n                titles_mal |= {\n                    t\n                    for t in [i.alternative_titles.native, i.alternative_titles.english]\n                    if t is not None\n                }\n                titles_mal |= (\n                    set(i.alternative_titles.romaji)\n                    if i.alternative_titles.romaji is not None\n                    else set()\n                )\n            titles_provider |= set(anime.get_info().alternative_names or [])\n\n        ratio = self._find_best_ratio(titles_mal, titles_provider)\n\n        if ratio &gt; best_ratio:\n            best_ratio = ratio\n            best_anime = i\n\n        if best_ratio == 1:\n            break\n\n    if best_ratio &gt;= minimum_similarity_ratio:\n        return best_anime\n</code></pre>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListAlternativeTitles","title":"<code>AniListAlternativeTitles(english=None, native=None, romaji=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds alternative anime titles.</p> <p>Attributes:</p> Name Type Description <code>en</code> <p>The (offical) english variant of the name</p> <code>ja</code> <p>The (offical) japanese variant of the name</p> <code>synonyms</code> <p>Other synonymous names</p>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListAnime","title":"<code>AniListAnime(id, title, media_type, num_episodes=None, alternative_titles=None, year=None, season=None, my_list_status=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds information about an anime and the user's list status if the anime is in their list.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Id of the anime</p> <code>title</code> <code>Title</code> <p>Title of the anime</p> <code>media_type</code> <code>AniListMediaTypeEnum</code> <p>Media type of the anime</p> <code>num_episodes</code> <code>Optional[int]</code> <p>Number of episodes the anime has, if unknown it is 0</p> <code>alternative_titles</code> <code>Optional[AniListAlternativeTitles]</code> <p>Alternative titles for an anime</p> <code>start_season</code> <code>Optional[AniListAlternativeTitles]</code> <p>Season/Year the anime started in</p> <code>my_list_status</code> <code>Optional[AniListMyListStatus]</code> <p>If the anime is in the user's list, this holds the information of the list status</p>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListMediaTypeEnum","title":"<code>AniListMediaTypeEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of possible media types.</p> <p>Attributes:</p> Name Type Description <code>TV</code> <code>TV_SHORT</code> <code>MOVIE</code> <code>SPECIAL</code> <code>OVA</code> <code>ONA</code> <code>MUSIC</code>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListMyListStatus","title":"<code>AniListMyListStatus(entry_id, notes, num_episodes_watched, status, score, tags=list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds a user's list status. It accompanies AniListAnime.</p> <p>Attributes:</p> Name Type Description <code>entry_id</code> <code>int</code> <p>The unique ID of the user's list entry. Used to identify this anime entry in the user's AniList media list.</p> <code>num_episodes_watched</code> <code>int</code> <p>Watched episodes, this number may exceed that of the <code>num_episodes</code> in AniListAnime as it can be abitrarily large.</p> <code>tags</code> <code>List[str]</code> <p>List of tags associated with the anime</p> <code>status</code> <code>AniListMyListStatusEnum</code> <p>Current status of the anime</p> <code>score</code> <code>int</code> <p>The user's score of the anime</p>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListMyListStatusEnum","title":"<code>AniListMyListStatusEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of possible list states.</p> <p>Attributes:</p> Name Type Description <code>WATCHING</code> <code>COMPLETED</code> <code>ON_HOLD</code> <code>DROPPED</code> <code>PLAN_TO_WATCH</code> <code>REPEATING</code>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListSeasonEnum","title":"<code>AniListSeasonEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of possible seasons.</p> <p>Attributes:</p> Name Type Description <code>WINTER</code> <code>SPRING</code> <code>SUMMER</code> <code>FALL</code>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListStartSeason","title":"<code>AniListStartSeason(year, season)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds a season/year combination indicating the time this anime was aired in.</p> <p>Attributes:</p> Name Type Description <code>season</code> <code>AniListSeasonEnum</code> <p>Season of airing</p> <code>year</code> <code>int</code> <p>Year of airing</p>"},{"location":"reference/anipy_api/anilist/#anipy_api.anilist.AniListUser","title":"<code>AniListUser(id, name, picture=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds user data.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Users's id</p> <code>name</code> <code>str</code> <p>Users's name</p> <code>picture</code> <code>Optional[Picture]</code> <p>Users's profile picture</p>"},{"location":"reference/anipy_api/anime/","title":"anime","text":""},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime","title":"<code>Anime(provider, name, identifier, languages)</code>","text":"<p>A wrapper class that represents an anime, it is pretty useful, but you can also just use the Provider without the wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>BaseProvider</code> <p>The provider from which the identifier was retrieved</p> required <code>name</code> <code>str</code> <p>The name of the Anime</p> required <code>identifier</code> <code>str</code> <p>The identifier of the Anime</p> required <code>languages</code> <code>Set[LanguageTypeEnum]</code> <p>Supported Language types of the Anime</p> required <p>Attributes:</p> Name Type Description <code>provider</code> <code>BaseProvider</code> <p>The from which the Anime comes from</p> <code>name</code> <code>str</code> <p>The name of the Anime</p> <code>identifier</code> <code>str</code> <p>The identifier of the Anime</p> <code>languages</code> <code>Set[LanguageTypeEnum]</code> <p>Set of supported Language types of the Anime</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>def __init__(\n    self,\n    provider: \"BaseProvider\",\n    name: str,\n    identifier: str,\n    languages: Set[\"LanguageTypeEnum\"],\n):\n    self.provider: \"BaseProvider\" = provider\n    self.name: str = name\n    self.identifier: str = identifier\n    self.languages: Set[\"LanguageTypeEnum\"] = languages\n</code></pre>"},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime.from_local_list_entry","title":"<code>from_local_list_entry(entry)</code>  <code>staticmethod</code>","text":"<p>Get Anime object from LocalListEntry</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>LocalListEntry</code> <p>The local list entry</p> required <p>Returns:</p> Type Description <code>Anime</code> <p>Anime Object</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>@staticmethod\ndef from_local_list_entry(entry: \"LocalListEntry\") -&gt; \"Anime\":\n    \"\"\"Get Anime object from [LocalListEntry][anipy_api.locallist.LocalListEntry]\n\n    Args:\n        entry: The local list entry\n\n    Returns:\n        Anime Object\n    \"\"\"\n    provider = next(\n        filter(lambda x: x.NAME == entry.provider, list_providers()), None\n    )\n\n    if provider is None:\n        raise ProviderNotAvailableError(entry.provider)\n\n    return Anime(provider(), entry.name, entry.identifier, entry.languages)\n</code></pre>"},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime.from_search_result","title":"<code>from_search_result(provider, result)</code>  <code>staticmethod</code>","text":"<p>Get Anime object from ProviderSearchResult.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>BaseProvider</code> <p>The provider from which the search result stems from</p> required <code>result</code> <code>ProviderSearchResult</code> <p>The search result</p> required <p>Returns:</p> Type Description <code>Anime</code> <p>Anime object</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>@staticmethod\ndef from_search_result(\n    provider: \"BaseProvider\", result: \"ProviderSearchResult\"\n) -&gt; \"Anime\":\n    \"\"\"Get Anime object from ProviderSearchResult.\n\n    Args:\n        provider: The provider from which the search result stems from\n        result: The search result\n\n    Returns:\n        Anime object\n    \"\"\"\n    return Anime(provider, result.name, result.identifier, result.languages)\n</code></pre>"},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime.get_episodes","title":"<code>get_episodes(lang)</code>","text":"<p>Get a list of episodes from the Anime.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>LanguageTypeEnum</code> <p>Language type that determines if episodes are searched for the dub or sub version of the Anime. Use the <code>languages</code> attribute to get supported languages for this Anime.</p> required <p>Returns:</p> Type Description <code>List[Episode]</code> <p>List of Episodes</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>def get_episodes(self, lang: \"LanguageTypeEnum\") -&gt; List[\"Episode\"]:\n    \"\"\"Get a list of episodes from the Anime.\n\n    Args:\n        lang: Language type that determines if episodes are searched\n            for the dub or sub version of the Anime. Use the `languages`\n            attribute to get supported languages for this Anime.\n\n    Returns:\n        List of Episodes\n    \"\"\"\n    return self.provider.get_episodes(self.identifier, lang)\n</code></pre>"},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime.get_info","title":"<code>get_info()</code>","text":"<p>Get information about the Anime.</p> <p>Returns:</p> Type Description <code>ProviderInfoResult</code> <p>ProviderInfoResult object</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>def get_info(self) -&gt; \"ProviderInfoResult\":\n    \"\"\"Get information about the Anime.\n\n    Returns:\n        ProviderInfoResult object\n    \"\"\"\n    return self.provider.get_info(self.identifier)\n</code></pre>"},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime.get_video","title":"<code>get_video(episode, lang, preferred_quality=None)</code>","text":"<p>Get a video stream for the specified episode, the quality to return is determined by the <code>preferred_quality</code> argument or if this is not defined by the best quality found. To get a list of streams use get_videos.</p> <p>Parameters:</p> Name Type Description Default <code>episode</code> <code>Episode</code> <p>The episode to get the stream for</p> required <code>lang</code> <code>LanguageTypeEnum</code> <p>Language type that determines if streams are searched for the dub or sub version of the Anime. Use the <code>languages</code> attribute to get supported languages for this Anime.</p> required <code>preferred_quality</code> <code>Optional[Union[str, int]]</code> <p>This may be a integer (e.g. 1080, 720 etc.) or the string \"worst\" or \"best\".</p> <code>None</code> <p>Returns:</p> Type Description <code>ProviderStream</code> <p>A stream</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>def get_video(\n    self,\n    episode: Episode,\n    lang: \"LanguageTypeEnum\",\n    preferred_quality: Optional[Union[str, int]] = None,\n) -&gt; \"ProviderStream\":\n    \"\"\"Get a video stream for the specified episode, the quality to return\n    is determined by the `preferred_quality` argument or if this is not\n    defined by the best quality found. To get a list of streams use\n    [get_videos][anipy_api.anime.Anime.get_videos].\n\n    Args:\n        episode: The episode to get the stream for\n        lang: Language type that determines if streams are searched for\n            the dub or sub version of the Anime. Use the `languages`\n            attribute to get supported languages for this Anime.\n        preferred_quality: This may be a integer (e.g. 1080, 720 etc.)\n            or the string \"worst\" or \"best\".\n\n    Returns:\n        A stream\n    \"\"\"\n    streams = self.provider.get_video(self.identifier, episode, lang)\n    streams.sort(key=lambda s: s.resolution + (10 if s.subtitle else 0))\n\n    if preferred_quality == \"worst\":\n        stream = streams[0]\n    elif preferred_quality == \"best\":\n        stream = streams[-1]\n    elif preferred_quality is None:\n        stream = streams[-1]\n    else:\n        stream = next(\n            filter(lambda s: s.resolution == preferred_quality, streams), None\n        )\n\n        if stream is None:\n            stream = streams[-1]\n\n    return stream\n</code></pre>"},{"location":"reference/anipy_api/anime/#anipy_api.anime.Anime.get_videos","title":"<code>get_videos(episode, lang)</code>","text":"<p>Get a list of video streams for the specified Episode.</p> <p>Parameters:</p> Name Type Description Default <code>episode</code> <code>Episode</code> <p>The episode to get the streams for</p> required <code>lang</code> <code>LanguageTypeEnum</code> <p>Language type that determines if streams are searched for the dub or sub version of the Anime. Use the <code>languages</code> attribute to get supported languages for this Anime.</p> required <p>Returns:</p> Type Description <code>List[ProviderStream]</code> <p>A list of streams sorted by quality</p> Source code in <code>api/src/anipy_api/anime.py</code> <pre><code>def get_videos(\n    self, episode: Episode, lang: \"LanguageTypeEnum\"\n) -&gt; List[\"ProviderStream\"]:\n    \"\"\"Get a list of video streams for the specified Episode.\n\n    Args:\n        episode: The episode to get the streams for\n        lang: Language type that determines if streams are searched for\n            the dub or sub version of the Anime. Use the `languages`\n            attribute to get supported languages for this Anime.\n\n    Returns:\n        A list of streams sorted by quality\n    \"\"\"\n    streams = self.provider.get_video(self.identifier, episode, lang)\n    streams.sort(key=lambda s: s.resolution)\n\n    return streams\n</code></pre>"},{"location":"reference/anipy_api/download/","title":"download","text":""},{"location":"reference/anipy_api/download/#anipy_api.download.Downloader","title":"<code>Downloader(progress_callback=None, info_callback=None, soft_error_callback=None)</code>","text":"<p>Downloader class to download streams retrieved by the Providers.</p> <p>Parameters:</p> Name Type Description Default <code>progress_callback</code> <code>Optional[ProgressCallback]</code> <p>A callback with an percentage argument, that gets called on download progress.</p> <code>None</code> <code>info_callback</code> <code>Optional[InfoCallback]</code> <p>A callback with an message argument, that gets called on certain events.</p> <code>None</code> <code>soft_error_callback</code> <code>Optional[InfoCallback]</code> <p>A callback with a message argument, when certain events cause a non-fatal error (if none given, alternative fallback is info_callback).</p> <code>None</code> Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def __init__(\n    self,\n    progress_callback: Optional[ProgressCallback] = None,\n    info_callback: Optional[InfoCallback] = None,\n    soft_error_callback: Optional[InfoCallback] = None,\n):\n    \"\"\"__init__ of Downloader.\n\n    Args:\n        progress_callback: A callback with an percentage argument, that gets called on download progress.\n        info_callback: A callback with an message argument, that gets called on certain events.\n        soft_error_callback: A callback with a message argument, when certain events cause a non-fatal error (if none given, alternative fallback is info_callback).\n    \"\"\"\n    self._progress_callback: ProgressCallback = progress_callback or (\n        lambda percentage: None\n    )\n    self._info_callback: InfoCallback = info_callback or (\n        lambda message, exc_info=None: None\n    )\n    self._soft_error_callback: InfoCallback = (\n        soft_error_callback\n        or info_callback\n        or (lambda message, exc_info=None: None)\n    )\n\n    self._session = requests.Session()\n\n    adapter = HTTPAdapter(max_retries=Retry(connect=3, backoff_factor=0.5))\n    self._session.mount(\"http://\", adapter)\n    self._session.mount(\"https://\", adapter)\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.Downloader.download","title":"<code>download(stream, download_path, container=None, ffmpeg=False, max_retry=3, post_dl_cb=None)</code>","text":"<p>Generic download function that determines the best way to download a specific stream and downloads it. The suffix should be omitted here, you can instead use the <code>container</code> argument to remux the stream after the download, note that this will trigger the <code>progress_callback</code> again. This function assumes that ffmpeg is installed on the system, because if the stream is neither m3u8 or mp4 it will default to ffmpeg_download.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>ProviderStream</code> <p>The stream to download</p> required <code>download_path</code> <code>Path</code> <p>The path to download the stream to.</p> required <code>container</code> <code>Optional[str]</code> <p>The container to remux the video to if it is not already correctly muxed, the user must have ffmpeg installed on the system. Containers may include all containers supported by FFmpeg e.g. \".mp4\", \".mkv\" etc...</p> <code>None</code> <code>ffmpeg</code> <code>bool</code> <p>Wheter to automatically default to ffmpeg_download for m3u8/hls streams.</p> <code>False</code> <code>max_retry</code> <code>int</code> <p>The amount of times the API can retry the download</p> <code>3</code> <code>post_dl_cb</code> <code>Optional[PostDownloadCallback]</code> <p>Called when completing download, not called when file already exsists</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path of the resulting file</p> Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def download(\n    self,\n    stream: \"ProviderStream\",\n    download_path: Path,\n    container: Optional[str] = None,\n    ffmpeg: bool = False,\n    max_retry: int = 3,\n    post_dl_cb: Optional[PostDownloadCallback] = None,\n) -&gt; Path:\n    \"\"\"Generic download function that determines the best way to download a\n    specific stream and downloads it. The suffix should be omitted here,\n    you can instead use the `container` argument to remux the stream after\n    the download, note that this will trigger the `progress_callback`\n    again. This function assumes that ffmpeg is installed on the system,\n    because if the stream is neither m3u8 or mp4 it will default to\n    [ffmpeg_download][anipy_api.download.Downloader.ffmpeg_download].\n\n    Args:\n        stream: The stream to download\n        download_path: The path to download the stream to.\n        container: The container to remux the video to if it is not already\n            correctly muxed, the user must have ffmpeg installed on the system.\n            Containers may include all containers supported by FFmpeg e.g. \".mp4\", \".mkv\" etc...\n        ffmpeg: Wheter to automatically default to\n            [ffmpeg_download][anipy_api.download.Downloader.ffmpeg_download] for m3u8/hls streams.\n        max_retry: The amount of times the API can retry the download\n        post_dl_cb: Called when completing download, not called when file already exsists\n\n    Returns:\n        The path of the resulting file\n    \"\"\"\n    curr_exc: Exception | None = None\n    post_dl_cb = post_dl_cb or (lambda path, stream: None)\n    for i in range(max_retry):\n        try:\n            path = self._download_single_try(\n                stream, download_path, post_dl_cb, container, ffmpeg\n            )\n            return path\n        except DownloadError as e:\n            self._soft_error_callback(str(e))\n            curr_exc = e\n        except Exception as e:\n            self._soft_error_callback(f\"An error occurred during download: {e}\")\n            curr_exc = e\n        self._soft_error_callback(f\"{max_retry-i-1} retries remain\")\n\n    # Impossible, but to make the type\n    # checker happy\n    if curr_exc is None:\n        raise DownloadError(\"Unknown error occurred\")\n    # If retrying doesn't work, double it and\n    # give it to the next exception handler\n    raise curr_exc\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.Downloader.ffmpeg_download","title":"<code>ffmpeg_download(stream, download_path)</code>","text":"<p>Download a stream with FFmpeg, FFmpeg needs to be installed on the system. FFmpeg will be able to handle about any stream and it is also able to remux the resulting video. By changing the suffix of the <code>download_path</code> you are able to tell ffmpeg to remux to a specific container.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>ProviderStream</code> <p>The stream</p> required <code>download_path</code> <code>Path</code> <p>The path to download to including a specific suffix.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The download path, this should be the same as the</p> <code>Path</code> <p>passed one as ffmpeg will remux to about any container.</p> Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def ffmpeg_download(self, stream: \"ProviderStream\", download_path: Path) -&gt; Path:\n    \"\"\"Download a stream with FFmpeg, FFmpeg needs to be installed on the\n    system. FFmpeg will be able to handle about any stream and it is also\n    able to remux the resulting video. By changing the suffix of the\n    `download_path` you are able to tell ffmpeg to remux to a specific\n    container.\n\n    Args:\n        stream: The stream\n        download_path: The path to download to including a specific suffix.\n\n    Returns:\n        The download path, this should be the same as the\n        passed one as ffmpeg will remux to about any container.\n    \"\"\"\n\n    ffprobe = (\n        FFmpeg(executable=\"ffprobe\")\n        .option(\"v\", 0)\n        .option(\"of\", \"json\")\n        .option(\"show_program_version\")\n    )\n    version = json.loads(ffprobe.execute())\n    version = [\n        int(''.join(c for c in v if c.isdigit())) for v in version[\"program_version\"][\"version\"].split(\"-\")[0].split(\".\")\n    ]\n\n    if len(version) &lt; 3:\n        version.append(0)\n\n    major_v, minor_v, patch_v = version\n\n    extension_picky = major_v &gt;= 7 and minor_v &gt;= 1 and patch_v &gt;= 1\n\n    ffprobe = FFmpeg(executable=\"ffprobe\").input(\n        stream.url, print_format=\"json\", show_format=None\n    )\n\n    if stream.referrer:\n        ffprobe.option(\"headers\", f\"Referer: {stream.referrer}\")\n\n    if extension_picky:\n        ffprobe.option(\"extension_picky\", 0)\n\n    meta = json.loads(ffprobe.execute())\n    duration = float(meta[\"format\"][\"duration\"])\n\n    output_options: Dict[str, Any] = {\n        \"c:v\": \"copy\",\n        \"c:a\": \"copy\",\n        \"c:s\": \"mov_text\"\n    }\n\n    if extension_picky:\n        output_options.update({\"extension_picky\": 0})\n\n    ffmpeg = (\n        FFmpeg()\n        .option(\"y\")\n        .option(\"v\", \"warning\")\n        .option(\"stats\")\n        .input(stream.url)\n        .output(\n            download_path,\n            output_options\n        )\n    )\n\n    if stream.referrer:\n        ffmpeg.option(\"headers\", f\"Referer: {stream.referrer}\")\n\n    @ffmpeg.on(\"progress\")\n    def on_progress(progress: Progress):\n        self._progress_callback(progress.time.total_seconds() / duration * 100)\n\n    try:\n        ffmpeg.execute()\n    except KeyboardInterrupt:\n        self._info_callback(\"interrupted deleting partially downloaded file\")\n        download_path.unlink()\n        raise\n\n    return download_path\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.Downloader.m3u8_download","title":"<code>m3u8_download(stream, download_path)</code>","text":"<p>Download a m3u8/hls stream to a specified download path in a ts container.</p> <p>The suffix of the download path will be replaced (or added) with \".ts\", use the path returned instead of the passed path.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>ProviderStream</code> <p>The m3u8/hls stream</p> required <code>download_path</code> <code>Path</code> <p>The path to save the downloaded stream to</p> required <p>Raises:</p> Type Description <code>DownloadError</code> <p>Raised on download error</p> <p>Returns:</p> Type Description <code>Path</code> <p>The path with a \".ts\" suffix</p> Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def m3u8_download(self, stream: \"ProviderStream\", download_path: Path) -&gt; Path:\n    \"\"\"Download a m3u8/hls stream to a specified download path in a ts container.\n\n    The suffix of the download path will be replaced (or added) with\n    \".ts\", use the path returned instead of the passed path.\n\n    Args:\n        stream: The m3u8/hls stream\n        download_path: The path to save the downloaded stream to\n\n    Raises:\n        DownloadError: Raised on download error\n\n    Returns:\n        The path with a \".ts\" suffix\n    \"\"\"\n    temp_folder = download_path.parent / \"temp\"\n    temp_folder.mkdir(exist_ok=True)\n    download_path = download_path.with_suffix(\".ts\")\n    res = self._session.get(stream.url, headers={\"Referer\": stream.referrer})\n    res.raise_for_status()\n\n    m3u8_content = m3u8.M3U8(res.text, base_uri=urljoin(res.url, \".\"))\n\n    assert m3u8_content.is_variant is False\n\n    counter = 0\n\n    def download_ts(segment: m3u8.Segment):\n        nonlocal counter\n        url = urljoin(segment.base_uri, segment.uri)\n        segment_uri = Path(segment.uri)\n        fname = (\n            temp_folder / self._get_valid_pathname(segment_uri.stem)\n        ).with_suffix(segment_uri.suffix)\n        try:\n            res = self._session.get(str(url), headers={\"Referer\": stream.referrer})\n            res.raise_for_status()\n\n            with fname.open(\"wb\") as fout:\n                fout.write(res.content)\n\n            counter += 1\n            self._progress_callback(counter / len(m3u8_content.segments) * 100)\n        except Exception as e:\n            # TODO: This gets ignored, because it's in a seperate thread...\n            raise DownloadError(\n                f\"Encountered this error while downloading: {str(e)}\"\n            )\n\n    try:\n        with ThreadPoolExecutor(max_workers=12) as pool_video:\n            futures = [\n                pool_video.submit(download_ts, s) for s in m3u8_content.segments\n            ]\n            try:\n                for future in as_completed(futures):\n                    future.result()\n            except KeyboardInterrupt:\n                self._info_callback(\n                    \"Download Interrupted, cancelling futures, this may take a while...\"\n                )\n                pool_video.shutdown(wait=False, cancel_futures=True)\n                raise\n\n        self._info_callback(\"Parts Downloaded\")\n\n        self._info_callback(\"Merging Parts...\")\n        with download_path.open(\"wb\") as merged:\n            for segment in m3u8_content.segments:\n                uri = Path(segment.uri)\n                fname = (\n                    temp_folder / self._get_valid_pathname(uri.stem)\n                ).with_suffix(uri.suffix)\n                if not fname.is_file():\n                    raise DownloadError(\n                        f\"Could not merge, missing a segment of this playlist: {stream.url}\"\n                    )\n\n                with fname.open(\"rb\") as mergefile:\n                    shutil.copyfileobj(mergefile, merged)\n\n        self._info_callback(\"Merge Finished\")\n        shutil.rmtree(temp_folder)\n\n        return download_path\n    except KeyboardInterrupt:\n        self._info_callback(\"Download Interrupted, deleting partial file.\")\n        download_path.unlink(missing_ok=True)\n        shutil.rmtree(temp_folder)\n        raise\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.Downloader.mp4_download","title":"<code>mp4_download(stream, download_path)</code>","text":"<p>Download a mp4 stream to a specified download path.</p> <p>The suffix of the download path will be replaced (or added) with \".mp4\", use the path returned instead of the passed path.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>ProviderStream</code> <p>The mp4 stream</p> required <code>download_path</code> <code>Path</code> <p>The path to download the stream to</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The download path with a \".mp4\" suffix</p> Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def mp4_download(self, stream: \"ProviderStream\", download_path: Path) -&gt; Path:\n    \"\"\"Download a mp4 stream to a specified download path.\n\n    The suffix of the download path will be replaced (or added)\n    with \".mp4\", use the path returned instead of the passed path.\n\n    Args:\n        stream: The mp4 stream\n        download_path: The path to download the stream to\n\n    Returns:\n        The download path with a \".mp4\" suffix\n    \"\"\"\n    r = self._session.get(\n        stream.url, stream=True, headers={\"Referer\": stream.referrer}\n    )\n    r.raise_for_status()\n    total = int(r.headers.get(\"content-length\", 0))\n    try:\n\n        with download_path.with_suffix(\".mp4\").open(\"wb\") as file_handle:\n            downloaded_size = 0\n            for data in r.iter_content(chunk_size=1024):\n                downloaded_size += file_handle.write(data)\n                self._progress_callback(downloaded_size / total * 100)\n\n    except KeyboardInterrupt:\n        self._info_callback(\"Download Interrupted, deleting partial file.\")\n        download_path.unlink()\n        raise\n\n    self._info_callback(\"Download finished.\")\n\n    return download_path.with_suffix(\".mp4\")\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.InfoCallback","title":"<code>InfoCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Callback that accepts a message argument, and an exception.</p>"},{"location":"reference/anipy_api/download/#anipy_api.download.InfoCallback.__call__","title":"<code>__call__(message, exc_info=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message argument passed to the callback</p> required <code>exc_info</code> <code>Optional[BaseException]</code> <p>An exception to pass for logging</p> <code>None</code> Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def __call__(self, message: str, exc_info: Optional[BaseException] = None):\n    \"\"\"\n    Args:\n        message: Message argument passed to the callback\n        exc_info: An exception to pass for logging\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.PostDownloadCallback","title":"<code>PostDownloadCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Callback that accepts a message argument.</p>"},{"location":"reference/anipy_api/download/#anipy_api.download.PostDownloadCallback.__call__","title":"<code>__call__(path, stream)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path of the resulting download, passed to the callback</p> required <code>stream</code> <code>ProviderStream</code> <p>ProviderStream object passed to the callback</p> required Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def __call__(self, path: Path, stream: \"ProviderStream\"):\n    \"\"\"\n\n    Args:\n        path: Path of the resulting download, passed to the callback\n        stream: ProviderStream object passed to the callback\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/download/#anipy_api.download.ProgressCallback","title":"<code>ProgressCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Callback that accepts a percentage argument.</p>"},{"location":"reference/anipy_api/download/#anipy_api.download.ProgressCallback.__call__","title":"<code>__call__(percentage)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>percentage</code> <code>float</code> <p>Percentage argument passed to the callback</p> required Source code in <code>api/src/anipy_api/download.py</code> <pre><code>def __call__(self, percentage: float):\n    \"\"\"\n    Args:\n        percentage: Percentage argument passed to the callback\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/error/","title":"error","text":""},{"location":"reference/anipy_api/error/#anipy_api.error.AniListError","title":"<code>AniListError(url, status, anilist_api_error=None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised by AniList, this may include authentication errors or other HTTP errors.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Requested URL that caused the error</p> required <code>status</code> <code>int</code> <p>HTTP status code</p> required <code>anilist_api_error</code> <code>Optional[Dict]</code> <p>AniList api error if returned</p> <code>None</code> Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(\n    self, url: str, status: int, anilist_api_error: Optional[Dict] = None\n) -&gt; None:\n    \"\"\"__init__ for AniListError.\n\n    Args:\n        url: Requested URL that caused the error\n        status: HTTP status code\n        anilist_api_error: AniList api error if returned\n    \"\"\"\n    error_text = f\"Error requesting {url}, status is {status}.\"\n    if anilist_api_error:\n        error_text = f\"{error_text} Additional info from api {anilist_api_error}\"\n\n    super().__init__(error_text)\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.ArgumentError","title":"<code>ArgumentError(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised if something is wrong with the arguments provided to a callable.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Failure reason</p> required Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"__init__ for ArgumentError\n\n    Args:\n        message: Failure reason\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.BeautifulSoupLocationError","title":"<code>BeautifulSoupLocationError(what, where)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised in the Provider if there are errors with parsing HTML content.</p> <p>Parameters:</p> Name Type Description Default <code>what</code> <code>str</code> <p>What could not be parsed</p> required <code>where</code> <code>str</code> <p>The url of the to be parsed content</p> required Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(self, what: str, where: str):\n    \"\"\"__init__ for BeautifulSoupLocationError.\n\n    Args:\n        what: What could not be parsed\n        where: The url of the to be parsed content\n    \"\"\"\n    super().__init__(f\"Could not locate {what} at {where}\")\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.DownloadError","title":"<code>DownloadError(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised by Downloader.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Failure reason</p> required Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"__init__ for DownloadError.\n\n    Args:\n        message: Failure reason\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.LangTypeNotAvailableError","title":"<code>LangTypeNotAvailableError(identifier, provider, lang)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised in the Provider if the specified language type is not available.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Identifier of the Anime</p> required <code>provider</code> <code>str</code> <p>Name of the Provider</p> required <code>lang</code> <code>LanguageTypeEnum</code> <p>The language that is not available</p> required Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(self, identifier: str, provider: str, lang: \"LanguageTypeEnum\"):\n    \"\"\"__init__ for LangTypeNotAvailableError.\n\n    Args:\n        identifier: Identifier of the Anime\n        provider: Name of the Provider\n        lang: The language that is not available\n    \"\"\"\n    super().__init__(\n        f\"{str(lang).capitalize()} is not available for identifier `{identifier}` on provider `{provider}`\"\n    )\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.MyAnimeListError","title":"<code>MyAnimeListError(url, status, mal_api_error=None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised by MyAnimeList, this may include authentication errors or other HTTP errors.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Requested URL that caused the error</p> required <code>status</code> <code>int</code> <p>HTTP status code</p> required <code>mal_api_error</code> <code>Optional[Dict]</code> <p>MyAnimeList api error if returned</p> <code>None</code> Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(\n    self, url: str, status: int, mal_api_error: Optional[Dict] = None\n) -&gt; None:\n    \"\"\"__init__ for MyAnimeListError.\n\n    Args:\n        url: Requested URL that caused the error\n        status: HTTP status code\n        mal_api_error: MyAnimeList api error if returned\n    \"\"\"\n    error_text = f\"Error requesting {url}, status is {status}.\"\n    if mal_api_error:\n        error_text = f\"{error_text} Additional info from api {mal_api_error}\"\n\n    super().__init__(error_text)\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.PlayerError","title":"<code>PlayerError(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets throws by certain functions in the player module.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Failure reason</p> required Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"__init__ for PlayerError.\n\n    Args:\n        message: Failure reason\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/anipy_api/error/#anipy_api.error.ProviderNotAvailableError","title":"<code>ProviderNotAvailableError(provider)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error that gets raised if a requested provider is not available.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider in question</p> required Source code in <code>api/src/anipy_api/error.py</code> <pre><code>def __init__(self, provider: str):\n    \"\"\"__init__ for ProviderNotAvailableError\n\n    Args:\n        provider: Provider in question\n    \"\"\"\n    super().__init__(f\"Could not find provider '{provider}'\")\n</code></pre>"},{"location":"reference/anipy_api/locallist/","title":"locallist","text":""},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalList","title":"<code>LocalList(file, migrate_cb=None)</code>","text":"<p>This class can manage a list of Anime objects and some extra state. This is built for the cli, but it may also be used in a library for easy (de)serialization of Anime objects</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>Path of the list</p> required <code>migrate_cb</code> <code>Optional[MigrateCallback]</code> <p>Migration callback, look at MigrateCallback</p> <code>None</code> Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def __init__(self, file: Path, migrate_cb: Optional[MigrateCallback] = None):\n    \"\"\"__init__ of LocalList\n\n    Args:\n        file: Path of the list\n        migrate_cb: Migration callback, look at [MigrateCallback][anipy_api.locallist.MigrateCallback]\n    \"\"\"\n\n    self.file = file\n    if not self.file.is_file():\n        self.file.parent.mkdir(exist_ok=True, parents=True)\n        self.file.touch()\n        self.data = LocalListData({})\n        self.data.write(self.file)\n    else:\n        try:\n            self.data = LocalListData.from_json(self.file.read_text())\n        except KeyError:\n            if migrate_cb is None:\n                raise\n            self.data = migrate_cb(self.file)\n</code></pre>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalList.delete","title":"<code>delete(anime)</code>","text":"<p>Delete a entry from the local list.</p> <p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Union[Anime, LocalListEntry]</code> <p>The anime to delete this can be a Anime or LocalListEntry object</p> required <p>Returns:</p> Type Description <code>Optional[LocalListEntry]</code> <p>The deleted object or None if the anime to delete was not found in the local list</p> Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def delete(self, anime: Union[Anime, LocalListEntry]) -&gt; Optional[LocalListEntry]:\n    \"\"\"Delete a entry from the local list.\n\n    Args:\n        anime: The anime to delete this can be a [Anime][anipy_api.anime.Anime] or [LocalListEntry][anipy_api.locallist.LocalListEntry] object\n\n    Returns:\n        The deleted object or None if the anime to delete was not found in the local list\n    \"\"\"\n    self._read()\n\n    entry = self.data.data.pop(self._get_uid(anime), None)\n    self.data.write(self.file)\n\n    return entry\n</code></pre>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalList.get","title":"<code>get(anime)</code>","text":"<p>Get a specific local list entry.</p> <p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Anime</code> <p>The anime to get the local list entry from</p> required <p>Returns:</p> Type Description <code>Optional[LocalListEntry]</code> <p>A local list entry if it exists for the provided anime</p> Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def get(self, anime: Anime) -&gt; Optional[LocalListEntry]:\n    \"\"\"Get a specific local list entry.\n\n    Args:\n        anime: The anime to get the local list entry from\n\n    Returns:\n        A local list entry if it exists for the provided anime\n\n    \"\"\"\n    self._read()\n\n    return self.data.data.get(self._get_uid(anime), None)\n</code></pre>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalList.get_all","title":"<code>get_all()</code>","text":"<p>Get all of the local list entries.</p> <p>Returns:</p> Type Description <code>List[LocalListEntry]</code> <p>A list of all local list entries</p> Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def get_all(self) -&gt; List[LocalListEntry]:\n    \"\"\"Get all of the local list entries.\n\n    Returns:\n        A list of all local list entries\n    \"\"\"\n    self._read()\n\n    return list(self.data.data.values())\n</code></pre>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalList.update","title":"<code>update(anime, **update_fields)</code>","text":"<p>Update (or add) an anime in the local list.</p> Example <pre><code>from anipy_api.anime import Anime\nfrom anipy_api.locallist import LocalList\nfrom anipy_api.provider import LanguageTypeEnum\n\nanime = Anime(...)\nlocal_list = LocalList(...)\n\n# Adding an anime (1)\nlocal_list.update(anime, episode=1, language=LanguageTypeEnum.SUB)\n\n# Updating it (2)\nlocal_list.update(anime, episode=2)\n</code></pre> <ol> <li>When adding a anime make sure you are always passing at least the <code>episode</code> and <code>language</code> fields.</li> <li>When the anime is already added you can pass any update fields specified in the LocalListEntry class.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Union[Anime, LocalListEntry]</code> <p>The anime to update/add, this can be a Anime or LocalListEntry object</p> required <code>**update_fields</code> <code>Any</code> <p>The fields to update, they correspond to the fields in LocalListEntry</p> <code>{}</code> <p>Returns:</p> Type Description <code>LocalListEntry</code> <p>The updated entry</p> <p>Raises:</p> Type Description <code>ArgumentError</code> <p>Raised if updating a anime that does not exist (adding) and not providing at least the <code>episode</code> and <code>language</code> to the update_fields.</p> Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def update(\n    self, anime: Union[Anime, LocalListEntry], **update_fields: Any\n) -&gt; LocalListEntry:\n    \"\"\"Update (or add) an anime in the local list.\n\n    Example:\n        ```python\n        from anipy_api.anime import Anime\n        from anipy_api.locallist import LocalList\n        from anipy_api.provider import LanguageTypeEnum\n\n        anime = Anime(...)\n        local_list = LocalList(...)\n\n        # Adding an anime (1)\n        local_list.update(anime, episode=1, language=LanguageTypeEnum.SUB)\n\n        # Updating it (2)\n        local_list.update(anime, episode=2)\n        ```\n\n        1. When adding a anime make sure you are always passing at least the `episode` and `language` fields.\n        2. When the anime is already added you can pass any update fields specified in the [LocalListEntry][anipy_api.locallist.LocalListEntry] class.\n\n    Args:\n        anime: The anime to update/add, this can be a [Anime][anipy_api.anime.Anime] or [LocalListEntry][anipy_api.locallist.LocalListEntry] object\n        **update_fields: The fields to update, they correspond to the fields in [LocalListEntry][anipy_api.locallist.LocalListEntry]\n\n    Returns:\n        The updated entry\n\n    Raises:\n        ArgumentError: Raised if updating a anime that does not exist (adding) and not providing at\n            least the `episode` and `language` to the update_fields.\n    \"\"\"\n    self._read()\n\n    uid = self._get_uid(anime)\n    entry = self.data.data.get(uid, None)\n\n    if entry is None:\n        if not (\"episode\" in update_fields and \"language\" in update_fields):\n            raise ArgumentError(\n                \"The anime you are trying to update is not added to the list and you are not\"\n                \"providing the neccessary update_fields `episode` and `language`, this can not be processed\"\n            )\n\n        entry = LocalListEntry(\n            provider=str(anime.provider),\n            identifier=anime.identifier,\n            name=anime.name,\n            timestamp=int(time()),\n            episode=update_fields[\"episode\"],\n            language=update_fields[\"language\"],\n            languages=anime.languages,\n        )\n    else:\n        entry_dict = entry.to_dict()\n\n        for k, v in update_fields.items():\n            try:\n                entry_dict[k] = v\n            except KeyError:\n                continue\n\n        entry = LocalListEntry.from_dict(entry_dict)\n        entry.timestamp = int(time())\n\n    self.data.data[uid] = entry\n    self.data.write(self.file)\n\n    return entry\n</code></pre>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalListData","title":"<code>LocalListData(data)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class to save local list data</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, LocalListEntry]</code> <p>The dict with the data, this is always \"uid: value\". The uid is \"{provider}:{identifier}\"</p>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalListData.write","title":"<code>write(file)</code>","text":"<p>Writes the data of the current LocalListData object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>File path to write to (this should be a .json file)</p> required Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def write(self, file: Path):\n    \"\"\"Writes the data of the current LocalListData object to a file.\n\n    Args:\n        file: File path to write to (this should be a .json file)\n    \"\"\"\n    file.write_text(self.to_json())\n</code></pre>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.LocalListEntry","title":"<code>LocalListEntry(provider, identifier, name, episode, timestamp, language, languages)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable local list entry class that can be saved to a file and includes various information to rebuild state after deserializing.</p> <p>Attributes:</p> Name Type Description <code>provider</code> <code>str</code> <p>The provider of the anime</p> <code>identifier</code> <code>str</code> <p>The identifier of the anime</p> <code>name</code> <code>str</code> <p>The name of the anime</p> <code>episode</code> <code>Episode</code> <p>The current episode</p> <code>timestamp</code> <code>int</code> <p>The timestamp when this entry got updated/created (for sorting)</p> <code>language</code> <code>LanguageTypeEnum</code> <p>The language that the anime was in</p> <code>languages</code> <code>Set[LanguageTypeEnum]</code> <p>A list of languages the anime supports</p>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.MigrateCallback","title":"<code>MigrateCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Callback that gets called upon a KeyError while loading a file in the LocalList class, in a attempt to migrate data that may be in an old format. This callback should either return a migrated LocalListData object or a empty LocalListData object if migration fails (could also just raise a exception).</p>"},{"location":"reference/anipy_api/locallist/#anipy_api.locallist.MigrateCallback.__call__","title":"<code>__call__(file)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The file path that is passed to the callback to migrate</p> required Source code in <code>api/src/anipy_api/locallist.py</code> <pre><code>def __call__(self, file: Path) -&gt; LocalListData:\n    \"\"\"\n    Args:\n        file: The file path that is passed to the callback to migrate\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/mal/","title":"mal","text":""},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALAlternativeTitles","title":"<code>MALAlternativeTitles(en=None, ja=None, synonyms=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds alternative anime titles.</p> <p>Attributes:</p> Name Type Description <code>en</code> <code>Optional[str]</code> <p>The (offical) english variant of the name</p> <code>ja</code> <code>Optional[str]</code> <p>The (offical) japanese variant of the name</p> <code>synonyms</code> <code>Optional[List[str]]</code> <p>Other synonymous names</p>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALAnime","title":"<code>MALAnime(id, title, media_type, num_episodes, alternative_titles=None, start_season=None, my_list_status=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds information about an anime and the user's list status if the anime is in their list.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Id of the anime</p> <code>title</code> <code>str</code> <p>Title of the anime</p> <code>media_type</code> <code>MALMediaTypeEnum</code> <p>Media type of the anime</p> <code>num_episodes</code> <code>int</code> <p>Number of episodes the anime has, if unknown it is 0</p> <code>alternative_titles</code> <code>Optional[MALAlternativeTitles]</code> <p>Alternative titles for an anime</p> <code>start_season</code> <code>Optional[MALStartSeason]</code> <p>Season/Year the anime started in</p> <code>my_list_status</code> <code>Optional[MALMyListStatus]</code> <p>If the anime is in the user's list, this holds the information of the list status</p>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALMediaTypeEnum","title":"<code>MALMediaTypeEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of possible media types.</p> <p>Attributes:</p> Name Type Description <code>TV</code> <code>MOVIE</code> <code>OVA</code> <code>ONA</code> <code>SPECIAL</code> <code>TV_SPECIAL</code> <code>MUSIC</code> <code>CM</code> <code>UNKNOWN</code>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALMyListStatus","title":"<code>MALMyListStatus(num_episodes_watched, tags, status, score)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds a user's list status. It accompanies MALAnime.</p> <p>Attributes:</p> Name Type Description <code>num_episodes_watched</code> <code>int</code> <p>Watched episodes, this number may exceed that of the <code>num_episodes</code> in MALAnime as it can be abitrarily large.</p> <code>tags</code> <code>List[str]</code> <p>List of tags associated with the anime</p> <code>status</code> <code>MALMyListStatusEnum</code> <p>Current status of the anime</p> <code>score</code> <code>int</code> <p>The user's score of the anime</p>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALMyListStatusEnum","title":"<code>MALMyListStatusEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of possible list states.</p> <p>Attributes:</p> Name Type Description <code>WATCHING</code> <code>COMPLETED</code> <code>ON_HOLD</code> <code>DROPPED</code> <code>PLAN_TO_WATCH</code>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALSeasonEnum","title":"<code>MALSeasonEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of possible seasons.</p> <p>Attributes:</p> Name Type Description <code>WINTER</code> <code>SPRING</code> <code>SUMMER</code> <code>FALL</code>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALStartSeason","title":"<code>MALStartSeason(season, year)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds a season/year combination indicating the time this anime was aired in.</p> <p>Attributes:</p> Name Type Description <code>season</code> <code>MALSeasonEnum</code> <p>Season of airing</p> <code>year</code> <code>int</code> <p>Year of airing</p>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MALUser","title":"<code>MALUser(id, name, picture=None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassJsonMixin</code></p> <p>A json-serializable class that holds user data.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Users's id</p> <code>name</code> <code>str</code> <p>Users's name</p> <code>picture</code> <code>Optional[str]</code> <p>Users's profile picture</p>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList","title":"<code>MyAnimeList(client_id=None)</code>","text":"<p>MyAnimeList api client that implements some of the endpoints documented here.</p> <p>Attributes:</p> Name Type Description <code>API_BASE</code> <p>The base url of the api (https://api.myanimelist.net/v2)</p> <code>CLIENT_ID</code> <p>The client being used to access the api</p> <code>RESPONSE_FIELDS</code> <p>Corresponds to fields of MALAnime object (read here for explaination)</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>Optional[str]</code> <p>Overrides the default client id</p> <code>None</code> Info <p>Please note that that currently no complex oauth autentication scheme is implemented, this client uses the client id of the official MyAnimeList android app, this gives us the ability to login via a username/password combination. If you pass your own client id you will not be able to use the from_password_grant function.</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def __init__(self, client_id: Optional[str] = None):\n    \"\"\"__init__ of MyAnimeList.\n\n    Args:\n        client_id: Overrides the default client id\n\n    Info:\n        Please note that that currently no complex oauth autentication scheme is\n        implemented, this client uses the client id of the official MyAnimeList\n        android app, this gives us the ability to login via a username/password\n        combination. If you pass your own client id you will not be able to use\n        the [from_password_grant][anipy_api.mal.MyAnimeList.from_password_grant] function.\n    \"\"\"\n    if client_id:\n        self.CLIENT_ID = client_id\n\n    self._refresh_token = None\n    self._auth_expire_time = datetime.datetime.min\n\n    self._session = Session()\n    self._session.headers.update(\n        {\n            \"X-MAL-Client-ID\": self.CLIENT_ID,\n        }\n    )\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.from_password_grant","title":"<code>from_password_grant(user, password, client_id=None)</code>  <code>staticmethod</code>","text":"<p>Authenticate via a username/password combination.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>MyAnimeList username</p> required <code>password</code> <code>str</code> <p>MyAnimeList password</p> required <code>client_id</code> <code>Optional[str]</code> <p>Overrides the default client id</p> <code>None</code> <p>Returns:</p> Type Description <code>MyAnimeList</code> <p>The MyAnimeList client object</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>@staticmethod\ndef from_password_grant(\n    user: str, password: str, client_id: Optional[str] = None\n) -&gt; \"MyAnimeList\":\n    \"\"\"Authenticate via a username/password combination.\n\n    Args:\n        user: MyAnimeList username\n        password: MyAnimeList password\n        client_id: Overrides the default client id\n\n    Returns:\n        The MyAnimeList client object\n    \"\"\"\n    mal = MyAnimeList(client_id)\n    mal._refresh_auth(user, password)\n    return mal\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.from_rt_grant","title":"<code>from_rt_grant(refresh_token, client_id=None)</code>  <code>staticmethod</code>","text":"<p>Authenticate via a refresh token. The refresh token will be saved in <code>MyAnimeList._refresh_token</code> and used to periodically refresh the access token, the refresh token may change if the current one expires.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>The refresh token</p> required <code>client_id</code> <code>Optional[str]</code> <p>Overrides the default client id</p> <code>None</code> <p>Returns:</p> Type Description <code>MyAnimeList</code> <p>The MyAnimeList client object</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>@staticmethod\ndef from_rt_grant(\n    refresh_token: str, client_id: Optional[str] = None\n) -&gt; \"MyAnimeList\":\n    \"\"\"Authenticate via a refresh token. The refresh token will be saved in\n    `MyAnimeList._refresh_token` and used to periodically refresh the\n    access token, the refresh token may change if the current one expires.\n\n    Args:\n        refresh_token: The refresh token\n        client_id: Overrides the default client id\n\n    Returns:\n        The MyAnimeList client object\n    \"\"\"\n    mal = MyAnimeList(client_id)\n    mal._refresh_token = refresh_token\n    mal._refresh_auth()\n    return mal\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.get_anime","title":"<code>get_anime(anime_id)</code>","text":"<p>Get a MyAnimeList anime by its id.</p> <p>Parameters:</p> Name Type Description Default <code>anime_id</code> <code>int</code> <p>The id of the anime</p> required <p>Returns:</p> Type Description <code>MALAnime</code> <p>The anime that corresponds to the id</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def get_anime(self, anime_id: int) -&gt; MALAnime:\n    \"\"\"Get a MyAnimeList anime by its id.\n\n    Args:\n        anime_id: The id of the anime\n\n    Returns:\n        The anime that corresponds to the id\n    \"\"\"\n    request = Request(\"GET\", f\"{self.API_BASE}/anime/{anime_id}\")\n    return MALAnime.from_dict(self._make_request(request))\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.get_anime_list","title":"<code>get_anime_list(status_filter=None)</code>","text":"<p>Get the anime list of the currently authenticated user.</p> <p>Parameters:</p> Name Type Description Default <code>status_filter</code> <code>Optional[MALMyListStatusEnum]</code> <p>A filter that determines which list status is retrieved</p> <code>None</code> <p>Returns:</p> Type Description <code>List[MALAnime]</code> <p>List of anime in the anime list</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def get_anime_list(\n    self, status_filter: Optional[MALMyListStatusEnum] = None\n) -&gt; List[MALAnime]:\n    \"\"\"Get the anime list of the currently authenticated user.\n\n    Args:\n        status_filter: A filter that determines which list status is retrieved\n\n    Returns:\n        List of anime in the anime list\n    \"\"\"\n    params = dict()\n    if status_filter:\n        params = {\"status\": status_filter.value}\n\n    return self._get_resource(\"users/@me/animelist\", params, limit=20, pages=-1)\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.get_search","title":"<code>get_search(query, limit=20, pages=1)</code>","text":"<p>Search MyAnimeList.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>limit</code> <code>int</code> <p>The amount of results per page</p> <code>20</code> <code>pages</code> <code>int</code> <p>The amount of pages to return, note the total number of results is limit times pages</p> <code>1</code> <p>Returns:</p> Type Description <code>List[MALAnime]</code> <p>A list of search results</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def get_search(self, query: str, limit: int = 20, pages: int = 1) -&gt; List[MALAnime]:\n    \"\"\"Search MyAnimeList.\n\n    Args:\n        query: Search query\n        limit: The amount of results per page\n        pages: The amount of pages to return,\n            note the total number of results is limit times pages\n\n    Returns:\n        A list of search results\n    \"\"\"\n    return self._get_resource(\"anime\", {\"q\": query}, limit, pages)\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.get_user","title":"<code>get_user()</code>","text":"<p>Get information about the currently authenticated user.</p> <p>Returns:</p> Type Description <code>MALUser</code> <p>A object with user information</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def get_user(self) -&gt; MALUser:\n    \"\"\"Get information about the currently authenticated user.\n\n    Returns:\n        A object with user information\n    \"\"\"\n    request = Request(\n        \"GET\", f\"{self.API_BASE}/users/@me\", params={\"fields\": \"id,name,picture\"}\n    )\n    return MALUser.from_dict(self._make_request(request))\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.remove_from_anime_list","title":"<code>remove_from_anime_list(anime_id)</code>","text":"<p>Remove an anime from the currently authenticated user's anime list.</p> <p>Parameters:</p> Name Type Description Default <code>anime_id</code> <code>int</code> <p>Id of the anime to be removed</p> required Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def remove_from_anime_list(self, anime_id: int):\n    \"\"\"Remove an anime from the currently authenticated user's anime list.\n\n    Args:\n        anime_id: Id of the anime to be removed\n    \"\"\"\n    request = Request(\"DELETE\", f\"{self.API_BASE}/anime/{anime_id}/my_list_status\")\n    self._make_request(request)\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeList.update_anime_list","title":"<code>update_anime_list(anime_id, status=None, watched_episodes=None, tags=None)</code>","text":"<p>Update a specific anime in the currently authenticated users's anime list. Only pass the arguments you want to update.</p> <p>Parameters:</p> Name Type Description Default <code>anime_id</code> <code>int</code> <p>The anime id of the anime to update</p> required <code>status</code> <code>Optional[MALMyListStatusEnum]</code> <p>Updated status of the anime</p> <code>None</code> <code>watched_episodes</code> <code>Optional[int]</code> <p>Updated watched episodes</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Updated list of tags, note that this ovewrites the already existing tags, if you want to retain the old ones you have to merge the old ones with the new ones yourself.</p> <code>None</code> <p>Returns:</p> Type Description <code>MALMyListStatus</code> <p>Object of the updated anime</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def update_anime_list(\n    self,\n    anime_id: int,\n    status: Optional[MALMyListStatusEnum] = None,\n    watched_episodes: Optional[int] = None,\n    tags: Optional[List[str]] = None,\n) -&gt; MALMyListStatus:\n    \"\"\"Update a specific anime in the currently authenticated users's anime\n    list. Only pass the arguments you want to update.\n\n    Args:\n        anime_id: The anime id of the anime to update\n        status: Updated status of the anime\n        watched_episodes: Updated watched episodes\n        tags: Updated list of tags, note that this **ovewrites** the already\n            existing tags, if you want to retain the old ones you have to merge\n            the old ones with the new ones yourself.\n\n    Returns:\n        Object of the updated anime\n    \"\"\"\n    data = {\n        k: v\n        for k, v in {\n            \"status\": status.value if status else None,\n            \"num_watched_episodes\": watched_episodes,\n            \"tags\": \",\".join(tags) if tags is not None else None,\n        }.items()\n        if v is not None\n    }\n    request = Request(\n        \"PATCH\", f\"{self.API_BASE}/anime/{anime_id}/my_list_status\", data=data\n    )\n\n    return MALMyListStatus.schema(unknown=\"exclude\").load(\n        self._make_request(request)\n    )\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeListAdapter","title":"<code>MyAnimeListAdapter(myanimelist, provider)</code>","text":"<p>A adapter class that can adapt MyAnimeList anime to Provider anime.</p> <p>Attributes:</p> Name Type Description <code>mal</code> <code>MyAnimeList</code> <p>The MyAnimeList object</p> <code>provider</code> <code>BaseProvider</code> <p>The provider object</p> <p>Parameters:</p> Name Type Description Default <code>myanimelist</code> <code>MyAnimeList</code> <p>The MyAnimeList object to use</p> required <code>provider</code> <code>BaseProvider</code> <p>The provider object to use</p> required Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def __init__(self, myanimelist: MyAnimeList, provider: \"BaseProvider\") -&gt; None:\n    \"\"\"__init__ of MyAnimeListAdapter.\n\n    Args:\n        myanimelist: The MyAnimeList object to use\n        provider: The provider object to use\n    \"\"\"\n    self.mal: MyAnimeList = myanimelist\n    self.provider: \"BaseProvider\" = provider\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeListAdapter.from_myanimelist","title":"<code>from_myanimelist(mal_anime, minimum_similarity_ratio=0.8, use_filters=True, use_alternative_names=True)</code>","text":"<p>Adapt an anime from a MALAnime to a provider Anime. This uses Levenshtein Distance to calculate the similarity of names.</p> <p>Parameters:</p> Name Type Description Default <code>mal_anime</code> <code>MALAnime</code> <p>The mal anime to adapt from</p> required <code>minimum_similarity_ratio</code> <code>float</code> <p>The minimum accepted similarity ratio. This should be a number from 0-1, 1 meaning the names are identical 0 meaning there are no identical charachters whatsoever. If it is not met the function will return None.</p> <code>0.8</code> <code>use_filters</code> <code>bool</code> <p>Use filters for the provider to cut down on possible wrong results, do note that this will take more time.</p> <code>True</code> <code>use_alternative_names</code> <code>bool</code> <p>Use alternative names for matching, this may yield a higher chance of finding a match but takes more time.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Anime]</code> <p>A Anime object if adapting was successfull</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def from_myanimelist(\n    self,\n    mal_anime: MALAnime,\n    minimum_similarity_ratio: float = 0.8,\n    use_filters: bool = True,\n    use_alternative_names: bool = True,\n) -&gt; Optional[Anime]:\n    \"\"\"Adapt an anime from a [MALAnime][anipy_api.mal.MALAnime] to a provider [Anime][anipy_api.anime.Anime].\n    This uses [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) to calculate the similarity of names.\n\n    Args:\n        mal_anime: The mal anime to adapt from\n        minimum_similarity_ratio: The minimum accepted similarity ratio. This should be a number from 0-1,\n            1 meaning the names are identical 0 meaning there are no identical charachters whatsoever.\n            If it is not met the function will return None.\n        use_filters: Use filters for the provider to cut down on possible wrong results, do note that this will take more time.\n        use_alternative_names: Use alternative names for matching, this may yield a higher chance of finding a match but takes more time.\n\n    Returns:\n        A Anime object if adapting was successfull\n\n    \"\"\"\n    mal_titles = {mal_anime.title}\n    if use_alternative_names and mal_anime.alternative_titles is not None:\n        mal_titles |= {\n            t\n            for t in [\n                mal_anime.alternative_titles.ja,\n                mal_anime.alternative_titles.en,\n            ]\n            if t is not None\n        }\n        mal_titles |= (\n            set(mal_anime.alternative_titles.synonyms)\n            if mal_anime.alternative_titles.synonyms is not None\n            else set()\n        )\n\n    provider_filters = Filters()\n    if (\n        self.provider.FILTER_CAPS &amp; FilterCapabilities.YEAR\n        and mal_anime.start_season is not None\n    ):\n        provider_filters.year = mal_anime.start_season.year\n\n    if (\n        self.provider.FILTER_CAPS &amp; FilterCapabilities.SEASON\n        and mal_anime.start_season is not None\n    ):\n        provider_filters.season = Season[\n            mal_anime.start_season.season.value.upper()\n        ]\n\n    if self.provider.FILTER_CAPS &amp; FilterCapabilities.MEDIA_TYPE:\n        if mal_anime.media_type not in (\n            MALMediaTypeEnum.UNKNOWN,\n            MALMediaTypeEnum.CM,\n        ):\n            if mal_anime.media_type == MALMediaTypeEnum.TV_SPECIAL:\n                m_type = MALMediaTypeEnum.SPECIAL\n            else:\n                m_type = mal_anime.media_type\n\n            provider_filters.media_type = MediaType[m_type.value.upper()]\n\n    results: Set[ProviderSearchResult] = set()\n    for title in mal_titles:\n        if len(title) == 0:\n            continue\n\n        results |= set(self.provider.get_search(title))\n        if use_filters:\n            results |= set(self.provider.get_search(title, provider_filters))\n\n    best_ratio = 0\n    best_anime = None\n    for r in results:\n        anime = Anime.from_search_result(self.provider, r)\n        provider_titles = {anime.name}\n\n        if use_alternative_names:\n            provider_titles |= set(anime.get_info().alternative_names or [])\n\n        ratio = self._find_best_ratio(mal_titles, provider_titles)\n\n        if ratio &gt; best_ratio:\n            best_ratio = ratio\n            best_anime = anime\n        elif (\n            best_anime is not None\n            and ratio == best_ratio\n            and len(anime.languages) &gt; len(best_anime.languages)\n        ):\n            # prefer anime with more language options\n            best_anime = anime\n\n        if best_ratio == 1:\n            break\n\n    if best_ratio &gt; minimum_similarity_ratio:\n        return best_anime\n</code></pre>"},{"location":"reference/anipy_api/mal/#anipy_api.mal.MyAnimeListAdapter.from_provider","title":"<code>from_provider(anime, minimum_similarity_ratio=0.8, use_alternative_names=True)</code>","text":"<p>Adapt an anime from provider Anime to a MALAnime. This uses Levenshtein Distance to calculate the similarity of names.</p> <p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Anime</code> <p>The anime to adapt from</p> required <code>minimum_similarity_ratio</code> <code>float</code> <p>The minimum accepted similarity ratio. This should be a number from 0-1, 1 meaning the names are identical 0 meaning there are no identical charachters whatsoever. If it is not met the function will return None.</p> <code>0.8</code> <code>use_alternative_names</code> <code>bool</code> <p>Use alternative names for matching, this may yield a higher chance of finding a match but takes more time.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[MALAnime]</code> <p>A MALAnime object if adapting was successfull</p> Source code in <code>api/src/anipy_api/mal.py</code> <pre><code>def from_provider(\n    self,\n    anime: Anime,\n    minimum_similarity_ratio: float = 0.8,\n    use_alternative_names: bool = True,\n) -&gt; Optional[MALAnime]:\n    \"\"\"Adapt an anime from provider [Anime][anipy_api.anime.Anime] to a [MALAnime][anipy_api.mal.MALAnime].\n    This uses [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) to calculate the similarity of names.\n\n    Args:\n        anime: The anime to adapt from\n        minimum_similarity_ratio: The minimum accepted similarity ratio. This should be a number from 0-1,\n            1 meaning the names are identical 0 meaning there are no identical charachters whatsoever.\n            If it is not met the function will return None.\n        use_alternative_names: Use alternative names for matching, this may yield a higher chance of finding\n            a match but takes more time.\n\n    Returns:\n        A MALAnime object if adapting was successfull\n    \"\"\"\n    results = self.mal.get_search(anime.name)\n\n    best_anime = None\n    best_ratio = 0\n    for i in results:\n        titles_mal = {i.title}\n        titles_provider = {anime.name}\n\n        if use_alternative_names:\n            if i.alternative_titles is not None:\n                titles_mal |= {\n                    t\n                    for t in [i.alternative_titles.ja, i.alternative_titles.en]\n                    if t is not None\n                }\n                titles_mal |= (\n                    set(i.alternative_titles.synonyms)\n                    if i.alternative_titles.synonyms is not None\n                    else set()\n                )\n            titles_provider |= set(anime.get_info().alternative_names or [])\n\n        ratio = self._find_best_ratio(titles_mal, titles_provider)\n\n        if ratio &gt; best_ratio:\n            best_ratio = ratio\n            best_anime = i\n\n        if best_ratio == 1:\n            break\n\n    if best_ratio &gt;= minimum_similarity_ratio:\n        return best_anime\n</code></pre>"},{"location":"reference/anipy_api/player/base/","title":"base","text":""},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayCallback","title":"<code>PlayCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Callback that gets called upon playing a title, it accepts a anime and the stream being played.</p>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayCallback.__call__","title":"<code>__call__(anime, stream)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Anime</code> <p>The anime argument passed to the callback. This is the currently playing anime.</p> required <code>stream</code> <code>ProviderStream</code> <p>The stream argument passed to the callback. That is the currently playing stream.</p> required Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>def __call__(self, anime: \"Anime\", stream: \"ProviderStream\"):\n    \"\"\"\n    Args:\n        anime: The anime argument passed to the callback. This is the currently playing anime.\n        stream: The stream argument passed to the callback. That is the currently playing stream.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayerBase","title":"<code>PlayerBase(play_callback=None)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The abstract base class for all the players.</p> <p>To list available players or get one by name, use list_players and get_player respectively.</p> <p>Parameters:</p> Name Type Description Default <code>play_callback</code> <code>Optional[PlayCallback]</code> <p>Callback called upon starting to play a title with <code>play_title</code></p> <code>None</code> Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>def __init__(self, play_callback: Optional[PlayCallback] = None):\n    \"\"\"__init__ of PlayerBase\n\n    Args:\n        play_callback: Callback called upon starting to play a title with `play_title`\n    \"\"\"\n    self._play_callback = play_callback\n</code></pre>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayerBase.kill_player","title":"<code>kill_player()</code>  <code>abstractmethod</code>","text":"<p>Kill the player.</p> Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>@abstractmethod\ndef kill_player(self):\n    \"\"\"Kill the player.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayerBase.play_file","title":"<code>play_file(path)</code>  <code>abstractmethod</code>","text":"<p>Play any file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file</p> required Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>@abstractmethod\ndef play_file(self, path: str):\n    \"\"\"Play any file.\n\n    Args:\n        path: The path to the file\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayerBase.play_title","title":"<code>play_title(anime, stream)</code>  <code>abstractmethod</code>","text":"<p>Play a stream of an anime.</p> <p>Parameters:</p> Name Type Description Default <code>anime</code> <code>Anime</code> <p>The anime</p> required <code>stream</code> <code>ProviderStream</code> <p>The stream</p> required Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>@abstractmethod\ndef play_title(self, anime: \"Anime\", stream: \"ProviderStream\"):\n    \"\"\"Play a stream of an anime.\n\n    Args:\n        anime: The anime\n        stream: The stream\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.PlayerBase.wait","title":"<code>wait()</code>  <code>abstractmethod</code>","text":"<p>Wait for the player to stop/close.</p> Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>@abstractmethod\ndef wait(self):\n    \"\"\"Wait for the player to stop/close.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/player/base/#anipy_api.player.base.SubProcessPlayerBase","title":"<code>SubProcessPlayerBase(player_path, extra_args, play_callback=None)</code>","text":"<p>               Bases: <code>PlayerBase</code></p> <p>The base class for all players that are run through a sub process.</p> <p>For documentation of the other functions look at the base class.</p> Example <p>Here is how you might implement such a player on your own: <pre><code>class Mpv(SubProcessPlayerBase):\n    def __init__(self, player_path: str, extra_args: List[str] = [], rpc_client=None):\n        self.player_args_template = [ # (1)\n            \"{stream_url}\",\n            \"--force-media-title={media_title}\",\n            \"--force-window=immediate\",\n            *extra_args,\n        ]\n\n        super().__init__(\n            rpc_client=rpc_client,\n            player_path=player_path,\n            extra_args=extra_args\n        )\n</code></pre></p> <ol> <li>This is the important part, those arguments will later be passed to the player. There are two format fields you can use <code>{stream_url}</code> and <code>{media_title}</code>.</li> </ol> <p>Attributes:</p> Name Type Description <code>player_args_template</code> <code>List[str]</code> <p>A list of arguments that are passed to the player command. Fields that are replaced are <code>{media_title}</code> and <code>{stream_url}</code>. This is only important if you are implementing your own player.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> <p>The path to the player's executable</p> required <code>extra_args</code> <code>List[str]</code> <p>Extra arguments to be passed to the player</p> required <code>play_callback</code> <code>Optional[PlayCallback]</code> <p>Callback called upon starting to play a title with <code>play_title</code></p> <code>None</code> Source code in <code>api/src/anipy_api/player/base.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    player_path: str,\n    extra_args: List[str],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ for SubProcessPlayerBase\n\n    Args:\n        player_path: The path to the player's executable\n        extra_args: Extra arguments to be passed to the player\n        play_callback: Callback called upon starting to play a title with `play_title`\n    \"\"\"\n    super().__init__(play_callback)\n\n    self._sub_proc = None\n    self._player_exec = player_path\n</code></pre>"},{"location":"reference/anipy_api/player/player/","title":"player","text":""},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.Iina","title":"<code>Iina(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The iina subprocess player class.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/iina.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Iina\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"{stream_url}\",\n        \"--mpv-force-media-title={media_title}\",\n        \"--sub-files={subtitles}\",\n        \"--referrer={referrer}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.Mpv","title":"<code>Mpv(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The mpv subprocess player class. For a controllable mpv look here.</p> Info <p>Not only mpv works but mpv forks like mpv.net also work.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/mpv.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Mpv\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"{stream_url}\",\n        \"--force-media-title={media_title}\",\n        \"--sub-files={subtitles}\",\n        \"--force-window=immediate\",\n        \"--referrer={referrer}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.MpvControllable","title":"<code>MpvControllable(play_callback=None, **mpv_args)</code>","text":"<p>               Bases: <code>PlayerBase</code></p> <p>This player can be controlled and it also does not close if the media is changed, the window stays open until <code>kill_player</code> is called. You need libmpv for this, check the python-mpv project's requirements to know where to get it.</p> <p>For detailed documentation about the functions have a look at the base class.</p> <p>If you want to use the extra features of the controllable player look here for documentation (or use your LSP), the python-mpv mpv instance lives in the mpv attribute.</p> <p>Attributes:</p> Name Type Description <code>mpv</code> <p>The python-mpv mpv instance</p> <p>Parameters:</p> Name Type Description Default <code>play_callback</code> <code>Optional[PlayCallback]</code> <p>Callback called upon starting to play a title with <code>play_title</code></p> <code>None</code> <code>**mpv_args</code> <code>Optional[Any]</code> <p>Arguments passed to the MPV instance check the python-mpv repo or check the official list of arguments. There are some default arguments set, if you specify any arguments here, all the defaults will be discarded and this will be used instead.</p> <code>{}</code> Source code in <code>api/src/anipy_api/player/players/mpv_control.py</code> <pre><code>def __init__(\n    self, play_callback: Optional[PlayCallback] = None, **mpv_args: Optional[Any]\n):\n    \"\"\"__init__ of MpvControllable\n\n    Args:\n        play_callback: Callback called upon starting to play a title with `play_title`\n        **mpv_args: Arguments passed to the MPV instance check the [python-mpv repo](https://github.com/jaseg/python-mpv?tab=readme-ov-file#usage)\n            or check the [official list of arguments](https://mpv.io/manual/master/#properties). There are some default arguments set, if you specify\n            any arguments here, all the defaults will be discarded and this will be used instead.\n    \"\"\"\n    super().__init__(play_callback=play_callback)\n\n    # I know this is a crime, but pytohn-mpv loads the so/dll on import and this will break all the stuff for people that do not have that.\n    from mpv import MPV\n\n    if len(mpv_args) &lt;= 1:\n        mpv_args = {\n            \"input_default_bindings\": True,\n            \"input_vo_keyboard\": True,\n            \"force_window\": \"immediate\",\n            \"title\": \"MPV - Receiving Links from anipy-cli\",\n            \"osc\": True,\n        }\n\n    self.mpv = MPV(**mpv_args)\n</code></pre>"},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.Syncplay","title":"<code>Syncplay(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The syncplay subprocess player class.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/syncplay.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Syncplay\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"--\",\n        \"--meta-title='{media_title}'\",\n        \"--sub-files={subtitles}\",\n        \"--referrer={referrer}\" \"{stream_url}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.Vlc","title":"<code>Vlc(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The vlc subprocess player class.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/vlc.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Vlc\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"--meta-title='{media_title}'\",\n        \"--http-referrer={referrer}\",\n        \"--input-slave={subtitles}\",\n        \"{stream_url}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.get_player","title":"<code>get_player(player, extra_args=[], play_callback=None)</code>","text":"<p>Get a fitting player class based on a player path.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Path</code> <p>Path to the player</p> required <code>extra_args</code> <code>List[str]</code> <p>Extra arguments to pass to players that support it</p> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <p>Callback called upon starting to play a title with <code>play_title</code></p> <code>None</code> <p>Raises:</p> Type Description <code>PlayerError</code> <p>If the player is not found</p> <p>Returns:</p> Type Description <code>PlayerBase</code> <p>The player class</p> Source code in <code>api/src/anipy_api/player/player.py</code> <pre><code>def get_player(\n    player: Path,\n    extra_args: List[str] = [],\n    play_callback: Optional[\"PlayCallback\"] = None,\n) -&gt; \"PlayerBase\":\n    \"\"\"Get a fitting player class based on a player path.\n\n    Args:\n        player: Path to the player\n        extra_args: Extra arguments to pass to players that support it\n        play_callback: Callback called upon starting to play a title with `play_title`\n\n    Raises:\n        PlayerError: If the player is not found\n\n    Returns:\n        The player class\n    \"\"\"\n    if Path(player.name).stem == \"mpv-controlled\":\n        return MpvControllable(play_callback=play_callback)\n\n    player_dict = {\n        \"mpv\": Mpv,\n        \"mpvnet\": Mpv,\n        \"vlc\": Vlc,\n        \"syncplay\": Syncplay,\n        \"iina\": Iina,\n    }\n\n    player_class = player_dict.get(Path(player.name).stem, None)\n\n    if player_class:\n        return player_class(\n            str(player), extra_args=extra_args, play_callback=play_callback\n        )\n    else:\n        raise PlayerError(f\"Specified player `{player}` is unknown\")\n</code></pre>"},{"location":"reference/anipy_api/player/player/#anipy_api.player.player.list_players","title":"<code>list_players()</code>","text":"<p>List all available players. Note that is not really useful as not all of them have the same <code>__init__</code> signature, better use get_player or directly import the players you want to use.</p> <p>Yields:</p> Type Description <code>Type[PlayerBase]</code> <p>Player classes (that still need to be initialized)</p> Source code in <code>api/src/anipy_api/player/player.py</code> <pre><code>def list_players() -&gt; Iterator[Type[\"PlayerBase\"]]:\n    \"\"\"List all available players. Note that is not really useful as not all of them have the same `__init__` signature, better use [get_player][anipy_api.player.player.get_player] or directly import the players you want to use.\n\n    Yields:\n        Player classes (that still need to be initialized)\n    \"\"\"\n    for p in __all__:\n        yield globals()[p]\n</code></pre>"},{"location":"reference/anipy_api/player/players/iina/","title":"iina","text":""},{"location":"reference/anipy_api/player/players/iina/#anipy_api.player.players.iina.Iina","title":"<code>Iina(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The iina subprocess player class.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/iina.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Iina\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"{stream_url}\",\n        \"--mpv-force-media-title={media_title}\",\n        \"--sub-files={subtitles}\",\n        \"--referrer={referrer}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/players/mpv/","title":"mpv","text":""},{"location":"reference/anipy_api/player/players/mpv/#anipy_api.player.players.mpv.Mpv","title":"<code>Mpv(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The mpv subprocess player class. For a controllable mpv look here.</p> Info <p>Not only mpv works but mpv forks like mpv.net also work.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/mpv.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Mpv\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"{stream_url}\",\n        \"--force-media-title={media_title}\",\n        \"--sub-files={subtitles}\",\n        \"--force-window=immediate\",\n        \"--referrer={referrer}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/players/mpv_control/","title":"mpv_control","text":""},{"location":"reference/anipy_api/player/players/mpv_control/#anipy_api.player.players.mpv_control.MpvControllable","title":"<code>MpvControllable(play_callback=None, **mpv_args)</code>","text":"<p>               Bases: <code>PlayerBase</code></p> <p>This player can be controlled and it also does not close if the media is changed, the window stays open until <code>kill_player</code> is called. You need libmpv for this, check the python-mpv project's requirements to know where to get it.</p> <p>For detailed documentation about the functions have a look at the base class.</p> <p>If you want to use the extra features of the controllable player look here for documentation (or use your LSP), the python-mpv mpv instance lives in the mpv attribute.</p> <p>Attributes:</p> Name Type Description <code>mpv</code> <p>The python-mpv mpv instance</p> <p>Parameters:</p> Name Type Description Default <code>play_callback</code> <code>Optional[PlayCallback]</code> <p>Callback called upon starting to play a title with <code>play_title</code></p> <code>None</code> <code>**mpv_args</code> <code>Optional[Any]</code> <p>Arguments passed to the MPV instance check the python-mpv repo or check the official list of arguments. There are some default arguments set, if you specify any arguments here, all the defaults will be discarded and this will be used instead.</p> <code>{}</code> Source code in <code>api/src/anipy_api/player/players/mpv_control.py</code> <pre><code>def __init__(\n    self, play_callback: Optional[PlayCallback] = None, **mpv_args: Optional[Any]\n):\n    \"\"\"__init__ of MpvControllable\n\n    Args:\n        play_callback: Callback called upon starting to play a title with `play_title`\n        **mpv_args: Arguments passed to the MPV instance check the [python-mpv repo](https://github.com/jaseg/python-mpv?tab=readme-ov-file#usage)\n            or check the [official list of arguments](https://mpv.io/manual/master/#properties). There are some default arguments set, if you specify\n            any arguments here, all the defaults will be discarded and this will be used instead.\n    \"\"\"\n    super().__init__(play_callback=play_callback)\n\n    # I know this is a crime, but pytohn-mpv loads the so/dll on import and this will break all the stuff for people that do not have that.\n    from mpv import MPV\n\n    if len(mpv_args) &lt;= 1:\n        mpv_args = {\n            \"input_default_bindings\": True,\n            \"input_vo_keyboard\": True,\n            \"force_window\": \"immediate\",\n            \"title\": \"MPV - Receiving Links from anipy-cli\",\n            \"osc\": True,\n        }\n\n    self.mpv = MPV(**mpv_args)\n</code></pre>"},{"location":"reference/anipy_api/player/players/syncplay/","title":"syncplay","text":""},{"location":"reference/anipy_api/player/players/syncplay/#anipy_api.player.players.syncplay.Syncplay","title":"<code>Syncplay(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The syncplay subprocess player class.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/syncplay.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Syncplay\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"--\",\n        \"--meta-title='{media_title}'\",\n        \"--sub-files={subtitles}\",\n        \"--referrer={referrer}\" \"{stream_url}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/player/players/vlc/","title":"vlc","text":""},{"location":"reference/anipy_api/player/players/vlc/#anipy_api.player.players.vlc.Vlc","title":"<code>Vlc(player_path, extra_args=[], play_callback=None)</code>","text":"<p>               Bases: <code>SubProcessPlayerBase</code></p> <p>The vlc subprocess player class.</p> <p>For detailed documentation about the functions and arguments have a look at the base class.</p> <p>Parameters:</p> Name Type Description Default <code>player_path</code> <code>str</code> required <code>extra_args</code> <code>List[str]</code> <code>[]</code> <code>play_callback</code> <code>Optional[PlayCallback]</code> <code>None</code> Source code in <code>api/src/anipy_api/player/players/vlc.py</code> <pre><code>def __init__(\n    self,\n    player_path: str,\n    extra_args: List[str] = [],\n    play_callback: Optional[PlayCallback] = None,\n):\n    \"\"\"__init__ of Vlc\n\n    Args:\n        player_path:\n        extra_args:\n        play_callback:\n    \"\"\"\n    self.player_args_template = [\n        \"--meta-title='{media_title}'\",\n        \"--http-referrer={referrer}\",\n        \"--input-slave={subtitles}\",\n        \"{stream_url}\",\n        *extra_args,\n    ]\n\n    super().__init__(\n        player_path=player_path, extra_args=extra_args, play_callback=play_callback\n    )\n</code></pre>"},{"location":"reference/anipy_api/provider/base/","title":"base","text":""},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.Episode","title":"<code>Episode = Union[int, float]</code>  <code>module-attribute</code>","text":"<p>Episode type, float or integer.</p>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.BaseProvider","title":"<code>BaseProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>This is the abstract base class for all the providers, use this as documentation to know how to use the providers.</p> <p>To get a list of Providers use the list_providers function or use get_provider to get a provider by name.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>The name of the provider</p> <code>BASE_URL</code> <code>str</code> <p>The base url of the provider</p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>The filter capabilities of the provider</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.BaseProvider.get_episodes","title":"<code>get_episodes(identifier, lang)</code>  <code>abstractmethod</code>","text":"<p>Get a list of episodes of an anime.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The identifier of the anime</p> required <code>lang</code> <code>LanguageTypeEnum</code> <p>The language type used to look up the episode list</p> required <p>Returns:</p> Type Description <code>List[Episode]</code> <p>A list of episodes</p> <p>Raises:</p> Type Description <code>LangTypeNotAvailableError</code> <p>Raised when the language provided is not available for the anime</p> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>@abstractmethod\ndef get_episodes(self, identifier: str, lang: LanguageTypeEnum) -&gt; List[Episode]:\n    \"\"\"Get a list of episodes of an anime.\n\n    Args:\n        identifier: The identifier of the anime\n        lang: The language type used to look up the episode list\n\n    Returns:\n        A list of episodes\n\n    Raises:\n        LangTypeNotAvailableError: Raised when the language provided is\n            not available for the anime\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.BaseProvider.get_info","title":"<code>get_info(identifier)</code>  <code>abstractmethod</code>","text":"<p>Get detailed information about an anime.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The identifier of the anime</p> required <p>Returns:</p> Type Description <code>ProviderInfoResult</code> <p>A information object</p> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>@abstractmethod\ndef get_info(self, identifier: str) -&gt; ProviderInfoResult:\n    \"\"\"Get detailed information about an anime.\n\n    Args:\n        identifier: The identifier of the anime\n\n    Returns:\n        A information object\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.BaseProvider.get_search","title":"<code>get_search(query, filters=Filters())</code>  <code>abstractmethod</code>","text":"<p>Search in the Provider.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query</p> required <code>filters</code> <code>Filters</code> <p>The filter object, check FILTER_CAPS to see which filters this provider supports</p> <code>Filters()</code> <p>Returns:</p> Type Description <code>List[ProviderSearchResult]</code> <p>A list of search results</p> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>@abstractmethod\ndef get_search(\n    self, query: str, filters: Filters = Filters()\n) -&gt; List[ProviderSearchResult]:\n    \"\"\"Search in the Provider.\n\n    Args:\n        query: The search query\n        filters: The filter object, check FILTER_CAPS\n            to see which filters this provider supports\n\n    Returns:\n        A list of search results\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.BaseProvider.get_video","title":"<code>get_video(identifier, episode, lang)</code>  <code>abstractmethod</code>","text":"<p>Get a list of video streams for a anime episode.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The identifier of the anime</p> required <code>episode</code> <code>Episode</code> <p>The episode to get the streams from</p> required <code>lang</code> <code>LanguageTypeEnum</code> <p>The language type used to look up the streams</p> required <p>Returns:</p> Type Description <code>List[ProviderStream]</code> <p>A list of video streams</p> <p>Raises:</p> Type Description <code>LangTypeNotAvailableError</code> <p>Raised when the language provided is not available for the anime</p> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>@abstractmethod\ndef get_video(\n    self, identifier: str, episode: Episode, lang: LanguageTypeEnum\n) -&gt; List[ProviderStream]:\n    \"\"\"Get a list of video streams for a anime episode.\n\n    Args:\n        identifier: The identifier of the anime\n        episode: The episode to get the streams from\n        lang: The language type used to look up the streams\n\n    Returns:\n        A list of video streams\n\n    Raises:\n        LangTypeNotAvailableError: Raised when the language provided is\n            not available for the anime\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.LanguageTypeEnum","title":"<code>LanguageTypeEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum that contains possible language types of anime.</p> <p>Attributes:</p> Name Type Description <code>SUB</code> <code>DUB</code>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.ProviderInfoResult","title":"<code>ProviderInfoResult(name=None, image=None, genres=None, synopsis=None, release_year=None, status=None, alternative_names=None)</code>  <code>dataclass</code>","text":"<p>A class that contains detailed information about an anime.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Name of the Anime</p> <code>image</code> <code>Optional[str]</code> <p>Image of the Anime</p> <code>genres</code> <code>Optional[List[str]]</code> <p>Genres of the Anime</p> <code>synopsis</code> <code>Optional[str]</code> <p>Synopsis of the Anime</p> <code>release_year</code> <code>Optional[int]</code> <p>Release year of the Anime</p> <code>status</code> <code>Optional[Status]</code> <p>Status of the anime</p> <code>alternative_names</code> <code>Optional[List[str]]</code> <p>List of alternative names</p>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.ProviderSearchResult","title":"<code>ProviderSearchResult(identifier, name, languages)</code>  <code>dataclass</code>","text":"<p>A class that contains information about a search result.</p> <p>Attributes:</p> Name Type Description <code>identifier</code> <code>str</code> <p>The identifier of the anime</p> <code>name</code> <code>str</code> <p>The name of the anime</p> <code>languages</code> <code>Set[LanguageTypeEnum]</code> <p>A set of supported language types for that anime</p>"},{"location":"reference/anipy_api/provider/base/#anipy_api.provider.base.ProviderStream","title":"<code>ProviderStream(url, resolution, episode, language, subtitle=None, referrer=None)</code>  <code>dataclass</code>","text":"<p>A class that contains information about a video stream.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>The url of the stream.</p> <code>resolution</code> <code>int</code> <p>The resolution (actually the width) of the stream. (e.g. 1080, 720 etc.)</p> <code>episode</code> <code>Episode</code> <p>The episode this stream is from</p> <code>language</code> <code>LanguageTypeEnum</code> <p>The language type this stream is in</p> <code>subtitle</code> <code>Optional[Dict[str, ExternalSub]]</code> <p>The subtitles available from this stream</p> <code>referrer</code> <code>Optional[str]</code> <p>Referrer to be set when downloading/viewing if necassary.</p>"},{"location":"reference/anipy_api/provider/filter/","title":"filter","text":""},{"location":"reference/anipy_api/provider/filter/#anipy_api.provider.filter.FilterCapabilities","title":"<code>FilterCapabilities</code>","text":"<p>               Bases: <code>Flag</code></p> <p>A Flag class that describes the filter capabilities of a provider. Look here to learn how to use this.</p> <p>Attributes:</p> Name Type Description <code>YEAR</code> <p>The provider is able to filter by year.</p> <code>SEASON</code> <p>The provider is able to filter by season.</p> <code>STATUS</code> <p>The provider is able to filter by status of anime.</p> <code>MEDIA_TYPE</code> <p>The provider is able to filter by media type of anime.</p> <code>NO_QUERY</code> <p>The provider accepts a empty query, this is useful if you want to for example get all anime in a specific season, you do not want to provide a query for that because then you will only get shown the anime in that specific season that match the query. If a provider supports <code>NO_QUERY</code> it means that if you search without query you get all available anime in its database.</p> <code>ALL</code> <p>The provider supports all of the capabilities above.</p>"},{"location":"reference/anipy_api/provider/filter/#anipy_api.provider.filter.Filters","title":"<code>Filters(year=None, season=None, status=None, media_type=None)</code>  <code>dataclass</code>","text":"<p>A flter class that acts as a filter collection</p> <p>Attributes:</p> Name Type Description <code>year</code> <code>Optional[int]</code> <p>The year to filter by</p> <code>season</code> <code>Optional[Season]</code> <p>The season to filter by</p> <code>status</code> <code>Optional[Status]</code> <p>The status to filter by</p> <code>media_type</code> <code>Optional[MediaType]</code> <p>The media type to filter by</p>"},{"location":"reference/anipy_api/provider/filter/#anipy_api.provider.filter.MediaType","title":"<code>MediaType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of mediatypes to filter by</p> <p>Attributes:</p> Name Type Description <code>TV</code> <code>MOVIE</code> <code>OVA</code> <code>ONA</code> <code>SPECIAL</code> <code>MUSIC</code>"},{"location":"reference/anipy_api/provider/filter/#anipy_api.provider.filter.Season","title":"<code>Season</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of seasons to filter by</p> <p>Attributes:</p> Name Type Description <code>SPRING</code> <code>SUMMER</code> <code>FALL</code> <code>WINTER</code>"},{"location":"reference/anipy_api/provider/filter/#anipy_api.provider.filter.Status","title":"<code>Status</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of anime states to filter by</p> <p>Attributes:</p> Name Type Description <code>UPCOMING</code> <code>ONGOING</code> <code>COMPLETED</code>"},{"location":"reference/anipy_api/provider/provider/","title":"provider","text":""},{"location":"reference/anipy_api/provider/provider/#anipy_api.provider.provider.AllAnimeProvider","title":"<code>AllAnimeProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>For detailed documentation have a look at the base class.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>allanime</p> <code>BASE_URL</code> <code>str</code> <p>https://allanime.day</p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>YEAR, MEDIA_TYPE, SEASON, NO_QUERY</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"},{"location":"reference/anipy_api/provider/provider/#anipy_api.provider.provider.AnimekaiProvider","title":"<code>AnimekaiProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>For detailed documentation have a look at the base class.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>animekai</p> <code>BASE_URL</code> <code>str</code> <p>https://animekai.to</p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>YEAR, SEASON, STATUS, MEDIA_TYPE, NO_QUERY</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"},{"location":"reference/anipy_api/provider/provider/#anipy_api.provider.provider.NativeProvider","title":"<code>NativeProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>For detailed documentation have a look at the base class.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>native </p> <code>BASE_URL</code> <code>str</code> <p>~/Videos </p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>NO_QUERY</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"},{"location":"reference/anipy_api/provider/provider/#anipy_api.provider.provider.get_provider","title":"<code>get_provider(name, base_url_override=None)</code>","text":"<p>Get a provider by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the provider to get</p> required <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[BaseProvider]</code> <p>The provider by name, if it exsists</p> Source code in <code>api/src/anipy_api/provider/provider.py</code> <pre><code>def get_provider(\n    name: str, base_url_override: Optional[str] = None\n) -&gt; Optional[\"BaseProvider\"]:\n    \"\"\"Get a provider by name.\n\n    Arguments:\n        name: Name of the provider to get\n        base_url_override: Override the url used by the provider.\n\n    Returns:\n        The provider by name, if it exsists\n    \"\"\"\n    for p in list_providers():\n        if p.NAME == name:\n            return p(base_url_override)\n</code></pre>"},{"location":"reference/anipy_api/provider/provider/#anipy_api.provider.provider.list_providers","title":"<code>list_providers()</code>","text":"<p>List all available providers.</p> <p>Yields:</p> Type Description <code>Type[BaseProvider]</code> <p>Provider classes (that still need to be instantiated)</p> Example <p>Here is how the cli uses this: <pre><code>def get_prefered_providers(mode: str) -&gt; Iterator[\"BaseProvider\"]:\n    config = Config()\n    preferred_providers = config.providers[mode]\n\n    if not preferred_providers:\n        error(\n            f\"you have no providers set for {mode} mode, look into your config\",\n            fatal=True,\n        )\n\n    for i in list_providers():\n        if i.NAME in preferred_providers:\n            url_override = config.provider_urls.get(i.NAME, None)\n            yield i(url_override)\n</code></pre></p> Source code in <code>api/src/anipy_api/provider/provider.py</code> <pre><code>def list_providers() -&gt; Iterator[Type[\"BaseProvider\"]]:\n    \"\"\"List all available providers.\n\n    Yields:\n        Provider classes (that still need to be instantiated)\n\n    Example:\n        Here is how the cli uses this:\n        ```python hl_lines=\"11-14\"\n        def get_prefered_providers(mode: str) -&gt; Iterator[\"BaseProvider\"]:\n            config = Config()\n            preferred_providers = config.providers[mode]\n\n            if not preferred_providers:\n                error(\n                    f\"you have no providers set for {mode} mode, look into your config\",\n                    fatal=True,\n                )\n\n            for i in list_providers():\n                if i.NAME in preferred_providers:\n                    url_override = config.provider_urls.get(i.NAME, None)\n                    yield i(url_override)\n        ```\n\n    \"\"\"\n    for p in __all__:\n        yield globals()[p]\n</code></pre>"},{"location":"reference/anipy_api/provider/utils/","title":"utils","text":"<p>These are only internal utils, which are not made to be used outside</p>"},{"location":"reference/anipy_api/provider/utils/#anipy_api.provider.utils.parsenum","title":"<code>parsenum(n)</code>","text":"<p>Parse a number be it a integer or float</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>str</code> <p>Number as a string</p> required <p>Returns:</p> Source code in <code>api/src/anipy_api/provider/utils.py</code> <pre><code>def parsenum(n: str):\n    \"\"\"Parse a number be it a integer or float\n\n    Args:\n        n: Number as a string\n\n    Returns:\n\n    \"\"\"\n    try:\n        return int(n)\n    except ValueError:\n        return float(n)\n</code></pre>"},{"location":"reference/anipy_api/provider/utils/#anipy_api.provider.utils.request_page","title":"<code>request_page(session, req)</code>","text":"<p>Prepare a request and send it.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>The requests session</p> required <code>req</code> <code>Request</code> <p>The request</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response of the request</p> Source code in <code>api/src/anipy_api/provider/utils.py</code> <pre><code>def request_page(session: \"Session\", req: \"Request\") -&gt; \"Response\":\n    \"\"\"Prepare a request and send it.\n\n    Args:\n        session: The requests session\n        req: The request\n\n    Returns:\n        Response of the request\n    \"\"\"\n    prepped = req.prepare()\n    prepped.headers[\"User-Agent\"] = (\n        \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36\"\n    )\n    res = session.send(prepped)\n    res.raise_for_status()\n    return res\n</code></pre>"},{"location":"reference/anipy_api/provider/providers/allanime_provider/","title":"allanime_provider","text":""},{"location":"reference/anipy_api/provider/providers/allanime_provider/#anipy_api.provider.providers.allanime_provider.AllAnimeProvider","title":"<code>AllAnimeProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>For detailed documentation have a look at the base class.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>allanime</p> <code>BASE_URL</code> <code>str</code> <p>https://allanime.day</p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>YEAR, MEDIA_TYPE, SEASON, NO_QUERY</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"},{"location":"reference/anipy_api/provider/providers/animekai_provider/","title":"animekai_provider","text":""},{"location":"reference/anipy_api/provider/providers/animekai_provider/#anipy_api.provider.providers.animekai_provider.AnimekaiProvider","title":"<code>AnimekaiProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>For detailed documentation have a look at the base class.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>animekai</p> <code>BASE_URL</code> <code>str</code> <p>https://animekai.to</p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>YEAR, SEASON, STATUS, MEDIA_TYPE, NO_QUERY</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"},{"location":"reference/anipy_api/provider/providers/native_provider/","title":"native_provider","text":""},{"location":"reference/anipy_api/provider/providers/native_provider/#anipy_api.provider.providers.native_provider.NativeProvider","title":"<code>NativeProvider(base_url_override=None)</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>For detailed documentation have a look at the base class.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <code>str</code> <p>native </p> <code>BASE_URL</code> <code>str</code> <p>~/Videos </p> <code>FILTER_CAPS</code> <code>FilterCapabilities</code> <p>NO_QUERY</p> <p>Parameters:</p> Name Type Description Default <code>base_url_override</code> <code>Optional[str]</code> <p>Override the url used by the provider.</p> <code>None</code> Source code in <code>api/src/anipy_api/provider/base.py</code> <pre><code>def __init__(self, base_url_override: Optional[str] = None):\n    \"\"\"__init__ of BaseProvider\n\n    Args:\n        base_url_override: Override the url used by the provider.\n    \"\"\"\n    if base_url_override is not None:\n        self.BASE_URL = base_url_override\n\n    self._generate_new_session()\n</code></pre>"}]}